{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Spire API Python Client","text":"<p>A robust and extensible Python client for interacting with the Spire Business Software API. This client provides an object-oriented interface to get, create, update, delete, query, filter, sort, and manage various Spire modules such as Sales Orders, Invoices, Inventory Items, and more.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\u2705 Object-oriented resource wrappers for each module (e.g., <code>salesOrder</code>, <code>invoice</code>, <code>item</code>)</li> <li>\ud83d\udd0d Full-text search via <code>q</code> parameter</li> <li>\ud83d\udd01 Pagination with <code>start</code> and <code>limit</code> support</li> <li>\ud83e\uddfe JSON-based advanced filtering (supports <code>$gt</code>, <code>$lt</code>, <code>$in</code>, <code>$or</code>, etc.)</li> <li>\u2195\ufe0f Multi-field sorting with ascending/descending control</li> <li>\ud83d\udd27 Clean abstraction layer for API endpoints</li> <li>\ud83d\udce6 Powered by <code>pydantic</code> models for validation</li> </ul>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>pip install spyreapi\n</code></pre>"},{"location":"#configuration","title":"\u2699\ufe0f Configuration","text":"<ul> <li>How to set up your spire client</li> </ul>"},{"location":"#find-your-spire-url","title":"Find your Spire URL","text":"<p>The base URL for the Spire API is the same url provided by Spire that you use to access Spire server and uses port 10880 as default: Replace {spire-url} with the url provided by Spire.</p> <ul> <li>https://{spire-url}:10880/api/v2/</li> </ul> <p>Spire Cloud If you are using Spire cloud you do not need to specify a port. The base URL for API for Spire Cloud customers would be:</p> <ul> <li>https://{spire-cloud-url}/api/v2/</li> </ul>"},{"location":"#set-up-your-client-with-your-credentials","title":"Set up your client with your credentials","text":"<pre><code>from spyre import Spire\n# host is your spire url and the port if applicable\nclient = Spire(host = 'your-spire-host', company = 'comapany-name' , username = 'username' , password = 'password' )\n\n</code></pre>"},{"location":"#example-updating-the-status-of-an-inventory-item","title":"Example : Updating the status of an inventory item","text":"<pre><code>item = client.inventory.items.get_item(1101)    # Gets item with id 1101\nitem.status = 1                                 # Use either item. or item.model. . item.model. will bring up all attributes\nitem.update()\n</code></pre>"},{"location":"api/client/","title":"Client","text":"<p>A lightweight to interact with the Spire API using requests sessions for connection reuse and authenticated calls.</p> Source code in <code>src/spyre/client.py</code> <pre><code>class SpireClient():    \n    \"\"\"A lightweight to interact with the Spire API using requests sessions for connection reuse and authenticated calls.\"\"\"\n\n    def __init__(self, host, company, username, password,):\n        \"\"\"\n        Initialize a SpireClient instance.\n\n        Args:\n            host (str): Spire Server host.\n            company (str): Spire company.\n            username (str): Spire user username.\n            password (str): Spire user password.\n        \"\"\"\n        self.session = requests.Session()\n        self.session.auth = (username, password)\n        self.session.headers.update({\n            \"accept\": \"application/json\",\n            \"content-type\": \"application/json\"\n        })\n        self.base_url = f\"https://{host}/api/v2/companies/{company}\"\n\n        try: \n            response = self.session.get(self.base_url)\n            if response.text == 'No such company intertes':\n                raise ValueError(f\"No company entries for {company}\")\n            if response.text == 'Unauthorized':\n                raise ValueError(f\"Invalid Authorization\")\n\n        except ConnectionError as conn_err:\n            print(f\"Connection error occurred for : {conn_err}\")\n\n        except Timeout as timeout_err:\n            print(f\"Request timed out: {timeout_err}\")\n\n        except RequestException as req_err:\n            print(f\"General error occurred: {req_err}\")\n\n\n    def _get(self, endpoint, params=None):\n\n        \"\"\"\n        Send a GET request to the Spire API.\n\n        This method constructs the full URL using the provided endpoint,\n        sends an HTTP GET request with optional query parameters, and returns\n        the parsed JSON response. Raises an HTTPError if the response contains\n        an unsuccessful status code.\n\n        Args:\n            endpoint (str): The relative API endpoint (e.g., 'inventory/items/123').\n            params (dict, optional): A dictionary of query parameters to include\n                in the request (e.g., {'status': 'active'}). Defaults to None.\n\n        Returns:\n            dict: The JSON-decoded response from the API.\n\n        Raises:\n            requests.exceptions.HTTPError: If the response contains an HTTP error status.\n        \"\"\"\n        url = f\"{self.base_url}/{endpoint.lstrip('/')}\"\n        response = self.session.get(url , params=params)\n        response.raise_for_status()\n        return response.json()\n\n    def _post(self, endpoint, data=None, json=None):\n        \"\"\"\n        Send a POST request to the Spire API.\n\n        Args:\n            endpoint (str): The relative API endpoint (e.g., 'sales/orders').\n            data (dict, optional): Data to send in the body of the request.\n            json (dict, optional): JSON data to send in the body of the request.\n\n        Returns:\n            dict: A dictionary containing the response status code, URL, content, and headers.\n\n        Raises:\n            requests.exceptions.HTTPError: If the response contains an HTTP error status.\n        \"\"\"\n\n        url = f\"{self.base_url}/{endpoint.lstrip('/')}\"\n        response = self.session.post(url, data=data, json=json)\n        response.raise_for_status()\n        return self._handle_response(response)\n\n    def _put(self, endpoint, data=None, json=None):\n        \"\"\"\n        Send a PUT request to the Spire API.\n\n        Args:\n            endpoint (str): The relative API endpoint (e.g., 'inventory/items/123').\n            data (dict, optional): Data to send in the body of the request.\n            json (dict, optional): JSON data to send in the body of the request.\n\n        Returns:\n            dict: The JSON-decoded response from the API.\n\n        Raises:\n            requests.exceptions.HTTPError: If the response contains an HTTP error status.\n        \"\"\"\n        url = f\"{self.base_url}/{endpoint.lstrip('/')}\"\n        response = self.session.put(url, data=data, json=json)\n        response.raise_for_status()\n        return response.json()\n\n    def _delete(self, endpoint):\n        \"\"\"\n        Send a DELETE request to the Spire API.\n\n        Args:\n            endpoint (str): The relative API endpoint to delete (e.g., 'inventory/items/123').\n\n        Returns:\n            bool: True if the deletion was successful (status code 200, 202, or 204), False otherwise.\n        \"\"\"\n        url = f\"{self.base_url}/{endpoint.lstrip('/')}\"\n        response = self.session.delete(url)\n        return response.status_code in (200, 202, 204)\n\n    def _handle_response(self, response):\n\n        try:\n            content = response.json()\n        except ValueError:\n            content = response.text\n        return{\n            \"status_code\": response.status_code,\n            \"url\": response.url,\n            \"content\": content,\n            \"headers\" : response.headers\n        }\n\n    def _query(\n        self,\n        endpoint: str,\n        resource_cls: Type[\"APIResource[T]\"],\n        *,\n        all: bool = False,\n        limit: int = 1000,\n        start: int = 0,\n        query: Optional[str] = None,\n        filter: Optional[Dict[str, Any]] = None,\n        sort: Optional[Dict[str, str]] = None,\n        **extra_params\n    ) -&gt; List[\"APIResource[T]\"]:\n        \"\"\"\n        Query a list of resources from a Spire API endpoint with support for\n        pagination, searching, filtering, and multi-level sorting.\n\n        Args:\n            endpoint (str): The API endpoint (e.g., 'sales/orders').\n            resource_cls (Type[APIResource[T]]): The resource wrapper class (e.g., SalesOrderResource).\n            all (bool, optional): If True, fetches all available pages of results.\n            limit (int, optional): Number of results per page (max 1000). Default is 1000.\n            start (int, optional): Starting offset for pagination. Default is 0.\n            q (str, optional): Free-text search query.\n            filter (dict, optional): Dictionary of filter criteria, which will be JSON-encoded.\n            sort (dict, optional): Dictionary of sorting rules (e.g., {\"orderDate\": \"desc\", \"orderNo\": \"asc\"}).\n            **extra_params: Any additional query parameters to pass to the API.\n\n        Returns:\n            List[APIResource[T]]: A list of wrapped resource instances.\n        \"\"\"\n        collected = []\n        current_start = start\n        remaining = limit\n        while True:\n\n            current_limit = min(remaining, 1000)\n            # Build the query params as a list of tuples to allow repeated keys like 'sort'\n            params: List[Tuple[str, Any]] = [\n                (\"start\", current_start),\n                (\"limit\", current_limit)\n            ]\n\n            if query:\n                params.append((\"q\", query))\n\n            if filter:\n                model_fields = resource_cls.Model.model_fields.keys()\n                invalid_fields = [key for key in filter.keys() if key not in model_fields]\n                if invalid_fields:\n                    raise ValueError(f\"Invalid filter field(s): {invalid_fields}. for {resource_cls.Model.__name__} \")\n\n                encoded_filter = json.dumps(filter)\n                params.append((\"filter\", encoded_filter))\n\n            if sort:\n                for field, direction in sort.items():\n                    prefix = \"-\" if direction.lower() == \"desc\" else \"\"\n                    params.append((\"sort\", f\"{prefix}{field}\"))\n\n            # Add any additional custom parameters\n            for k, v in extra_params.items():\n                params.append((k, v))\n\n            response = self._get(endpoint.rstrip(\"/\"), params=params)\n            items = response.get(\"records\", [])\n            count = response.get(\"count\", 0)\n\n            for item in items:\n                collected.append(resource_cls.from_json(item, self))\n\n            # Exit if:\n            # - 'all' is False and we reached the requested 'limit'\n            # - no more items are returned\n            if not all:\n                remaining -= len(items)\n                if remaining &lt;= 0 or len(items) == 0:\n                    break\n\n            # Exit if there are no more items available\n            if (current_start + current_limit) &gt;= count or len(items) == 0:\n                break\n\n            current_start += current_limit\n\n        return collected\n</code></pre>"},{"location":"api/client/#spyre.client.SpireClient.__init__","title":"<code>__init__(host, company, username, password)</code>","text":"<p>Initialize a SpireClient instance.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Spire Server host.</p> required <code>company</code> <code>str</code> <p>Spire company.</p> required <code>username</code> <code>str</code> <p>Spire user username.</p> required <code>password</code> <code>str</code> <p>Spire user password.</p> required Source code in <code>src/spyre/client.py</code> <pre><code>def __init__(self, host, company, username, password,):\n    \"\"\"\n    Initialize a SpireClient instance.\n\n    Args:\n        host (str): Spire Server host.\n        company (str): Spire company.\n        username (str): Spire user username.\n        password (str): Spire user password.\n    \"\"\"\n    self.session = requests.Session()\n    self.session.auth = (username, password)\n    self.session.headers.update({\n        \"accept\": \"application/json\",\n        \"content-type\": \"application/json\"\n    })\n    self.base_url = f\"https://{host}/api/v2/companies/{company}\"\n\n    try: \n        response = self.session.get(self.base_url)\n        if response.text == 'No such company intertes':\n            raise ValueError(f\"No company entries for {company}\")\n        if response.text == 'Unauthorized':\n            raise ValueError(f\"Invalid Authorization\")\n\n    except ConnectionError as conn_err:\n        print(f\"Connection error occurred for : {conn_err}\")\n\n    except Timeout as timeout_err:\n        print(f\"Request timed out: {timeout_err}\")\n\n    except RequestException as req_err:\n        print(f\"General error occurred: {req_err}\")\n</code></pre>"},{"location":"api/crm/","title":"Communications","text":""},{"location":"api/crm/#spyre.crm.CRMClient","title":"<code>CRMClient</code>","text":"Source code in <code>src/spyre/crm.py</code> <pre><code>class CRMClient():\n\n    def __init__(self, client: SpireClient):\n        self.client = client\n        self.endpoint = \"crm\"\n\n    def get_note(self, id : int) -&gt; \"note\":\n        \"\"\"\n        Retrieve a note by its ID.\n\n        Args:\n            id (int): The ID of the note to retrieve.\n\n        Returns:\n            note: The retrieved note\n        \"\"\"\n        response = self.client._get(f\"/{self.endpoint}/notes/{str(id)}\")\n        return note.from_json(response, self.client)\n</code></pre>"},{"location":"api/crm/#spyre.crm.CRMClient.get_note","title":"<code>get_note(id)</code>","text":"<p>Retrieve a note by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the note to retrieve.</p> required <p>Returns:</p> Name Type Description <code>note</code> <code>note</code> <p>The retrieved note</p> Source code in <code>src/spyre/crm.py</code> <pre><code>def get_note(self, id : int) -&gt; \"note\":\n    \"\"\"\n    Retrieve a note by its ID.\n\n    Args:\n        id (int): The ID of the note to retrieve.\n\n    Returns:\n        note: The retrieved note\n    \"\"\"\n    response = self.client._get(f\"/{self.endpoint}/notes/{str(id)}\")\n    return note.from_json(response, self.client)\n</code></pre>"},{"location":"api/customers/","title":"Customers","text":""},{"location":"api/customers/#spyre.customers.CustomerClient","title":"<code>CustomerClient</code>","text":"Source code in <code>src/spyre/customers.py</code> <pre><code>class CustomerClient():\n\n    def __init__(self, client : SpireClient):\n        self.client = client\n        self.endpoint = \"customers\"\n\n    def get_customer(self, id: int) -&gt; \"customer\":\n        \"\"\"\n        Retrieve a customer by ID.\n\n        Sends a GET request to the customer endpoint to fetch details of a specific customer.\n\n        Args:\n            id (int): The ID of the customer to retrieve.\n\n        Returns:\n            Customer: A Customer object populated with the retrieved data.\n        \"\"\"\n\n        response = self.client._get(f\"{self.endpoint}/{str(id)}\")\n        return customer.from_json(json_data=response, client=self.client)\n\n    def create_customer(self, customer : 'Customer') -&gt; \"customer\":\n        \"\"\"\n        Create a new customer.\n\n        Sends a POST request to the customer endpoint with the customer data\n        to create a new customer record.\n\n        Args:\n            customer (Customer): The Customer object containing the data to be created.\n\n        Returns:\n            Customer: The newly created Customer object returned by the API.\n        \"\"\"\n\n        response =  self.client._post(f\"/{self.endpoint}\", json=customer.model_dump(exclude_unset=True, exclude_none=True))\n        if response.get('status_code') == 201:\n            location = response.get('headers').get('location')\n            parsed_url = urlparse(location)\n            path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n            id = path_segments[-1]\n            return self.get_customer(id)\n        else:\n            error_message = response.get('content')\n            raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n\n    def update_customer(self, id : int, customer : 'Customer') -&gt; \"customer\":\n        \"\"\"\n        Update an existing customer by ID.\n\n        Sends a PUT request to update a customer record using the provided customer data.\n\n        Args:\n            id (int): The ID of the customer to update.\n            customer (Customer): A Pydantic model representing the updated customer data.\n\n        Returns:\n            customer: A new Customer instance built from the updated response data.\n        \"\"\"\n        response = self.client._put(f\"/{self.endpoint}/{str(id)}\", json=customer.model_dump(exclude_none=True, exclude_unset=True))\n        return customer.from_json(response, self.client)\n\n    def delete_customer(self, id : int) -&gt; bool:\n        \"\"\"\n        Delete a customer by ID.\n\n        Sends a DELETE request to the customer endpoint. Returns True if deletion was successful (HTTP 200/204),\n        otherwise returns False.\n\n        Args:\n            id (int): The ID of the customer to delete.\n\n        Returns:\n            bool: True if the customer was successfully deleted, False otherwise.\n        \"\"\"\n        return self.client._delete(f\"/{self.endpoint}/{str(id)}\")\n\n\n    def query_customers (\n        self,\n        *,\n        query: Optional[str] = None,\n        sort: Optional[Dict[str, str]] = None,\n        filter: Optional[Dict[str, Any]] = None,\n        all: bool = False,\n        limit: int = 1000,\n        start: int = 0,\n        **extra_params\n    ) -&gt; List[\"customer\"]:\n        \"\"\"\n        Query customer with optional full-text search, filtering, multi-field sorting, and pagination.\n\n        Args:\n            query (str, optional): Full-text search string.\n            sort (dict, optional): Dictionary of sorting rules (e.g., {\"orderDate\": \"desc\", \"orderNo\": \"asc\"}).\n            filter (dict, optional): Dictionary of filters to apply (will be JSON-encoded and URL-safe).\n            all (bool, optional): If True, retrieves all pages of results.\n            limit (int, optional): Number of results per page (max 1000).\n            start (int, optional): Starting offset for pagination.\n            **extra_params (Any): Any additional parameters to include in the query.\n\n        Returns:\n            List[customer]: List of wrapped customer resources.\n        \"\"\"\n        return self.client._query(\n            endpoint=self.endpoint,\n            resource_cls=customer,\n            query=query,\n            sort=sort,\n            filter=filter,\n            all=all,\n            limit=limit,\n            start=start,\n            **extra_params\n        )\n</code></pre>"},{"location":"api/customers/#spyre.customers.CustomerClient.create_customer","title":"<code>create_customer(customer)</code>","text":"<p>Create a new customer.</p> <p>Sends a POST request to the customer endpoint with the customer data to create a new customer record.</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>Customer</code> <p>The Customer object containing the data to be created.</p> required <p>Returns:</p> Name Type Description <code>Customer</code> <code>customer</code> <p>The newly created Customer object returned by the API.</p> Source code in <code>src/spyre/customers.py</code> <pre><code>def create_customer(self, customer : 'Customer') -&gt; \"customer\":\n    \"\"\"\n    Create a new customer.\n\n    Sends a POST request to the customer endpoint with the customer data\n    to create a new customer record.\n\n    Args:\n        customer (Customer): The Customer object containing the data to be created.\n\n    Returns:\n        Customer: The newly created Customer object returned by the API.\n    \"\"\"\n\n    response =  self.client._post(f\"/{self.endpoint}\", json=customer.model_dump(exclude_unset=True, exclude_none=True))\n    if response.get('status_code') == 201:\n        location = response.get('headers').get('location')\n        parsed_url = urlparse(location)\n        path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n        id = path_segments[-1]\n        return self.get_customer(id)\n    else:\n        error_message = response.get('content')\n        raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/customers/#spyre.customers.CustomerClient.delete_customer","title":"<code>delete_customer(id)</code>","text":"<p>Delete a customer by ID.</p> <p>Sends a DELETE request to the customer endpoint. Returns True if deletion was successful (HTTP 200/204), otherwise returns False.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the customer to delete.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the customer was successfully deleted, False otherwise.</p> Source code in <code>src/spyre/customers.py</code> <pre><code>def delete_customer(self, id : int) -&gt; bool:\n    \"\"\"\n    Delete a customer by ID.\n\n    Sends a DELETE request to the customer endpoint. Returns True if deletion was successful (HTTP 200/204),\n    otherwise returns False.\n\n    Args:\n        id (int): The ID of the customer to delete.\n\n    Returns:\n        bool: True if the customer was successfully deleted, False otherwise.\n    \"\"\"\n    return self.client._delete(f\"/{self.endpoint}/{str(id)}\")\n</code></pre>"},{"location":"api/customers/#spyre.customers.CustomerClient.get_customer","title":"<code>get_customer(id)</code>","text":"<p>Retrieve a customer by ID.</p> <p>Sends a GET request to the customer endpoint to fetch details of a specific customer.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the customer to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Customer</code> <code>customer</code> <p>A Customer object populated with the retrieved data.</p> Source code in <code>src/spyre/customers.py</code> <pre><code>def get_customer(self, id: int) -&gt; \"customer\":\n    \"\"\"\n    Retrieve a customer by ID.\n\n    Sends a GET request to the customer endpoint to fetch details of a specific customer.\n\n    Args:\n        id (int): The ID of the customer to retrieve.\n\n    Returns:\n        Customer: A Customer object populated with the retrieved data.\n    \"\"\"\n\n    response = self.client._get(f\"{self.endpoint}/{str(id)}\")\n    return customer.from_json(json_data=response, client=self.client)\n</code></pre>"},{"location":"api/customers/#spyre.customers.CustomerClient.query_customers","title":"<code>query_customers(*, query=None, sort=None, filter=None, all=False, limit=1000, start=0, **extra_params)</code>","text":"<p>Query customer with optional full-text search, filtering, multi-field sorting, and pagination.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Full-text search string.</p> <code>None</code> <code>sort</code> <code>dict</code> <p>Dictionary of sorting rules (e.g., {\"orderDate\": \"desc\", \"orderNo\": \"asc\"}).</p> <code>None</code> <code>filter</code> <code>dict</code> <p>Dictionary of filters to apply (will be JSON-encoded and URL-safe).</p> <code>None</code> <code>all</code> <code>bool</code> <p>If True, retrieves all pages of results.</p> <code>False</code> <code>limit</code> <code>int</code> <p>Number of results per page (max 1000).</p> <code>1000</code> <code>start</code> <code>int</code> <p>Starting offset for pagination.</p> <code>0</code> <code>**extra_params</code> <code>Any</code> <p>Any additional parameters to include in the query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[customer]</code> <p>List[customer]: List of wrapped customer resources.</p> Source code in <code>src/spyre/customers.py</code> <pre><code>def query_customers (\n    self,\n    *,\n    query: Optional[str] = None,\n    sort: Optional[Dict[str, str]] = None,\n    filter: Optional[Dict[str, Any]] = None,\n    all: bool = False,\n    limit: int = 1000,\n    start: int = 0,\n    **extra_params\n) -&gt; List[\"customer\"]:\n    \"\"\"\n    Query customer with optional full-text search, filtering, multi-field sorting, and pagination.\n\n    Args:\n        query (str, optional): Full-text search string.\n        sort (dict, optional): Dictionary of sorting rules (e.g., {\"orderDate\": \"desc\", \"orderNo\": \"asc\"}).\n        filter (dict, optional): Dictionary of filters to apply (will be JSON-encoded and URL-safe).\n        all (bool, optional): If True, retrieves all pages of results.\n        limit (int, optional): Number of results per page (max 1000).\n        start (int, optional): Starting offset for pagination.\n        **extra_params (Any): Any additional parameters to include in the query.\n\n    Returns:\n        List[customer]: List of wrapped customer resources.\n    \"\"\"\n    return self.client._query(\n        endpoint=self.endpoint,\n        resource_cls=customer,\n        query=query,\n        sort=sort,\n        filter=filter,\n        all=all,\n        limit=limit,\n        start=start,\n        **extra_params\n    )\n</code></pre>"},{"location":"api/customers/#spyre.customers.CustomerClient.update_customer","title":"<code>update_customer(id, customer)</code>","text":"<p>Update an existing customer by ID.</p> <p>Sends a PUT request to update a customer record using the provided customer data.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the customer to update.</p> required <code>customer</code> <code>Customer</code> <p>A Pydantic model representing the updated customer data.</p> required <p>Returns:</p> Name Type Description <code>customer</code> <code>customer</code> <p>A new Customer instance built from the updated response data.</p> Source code in <code>src/spyre/customers.py</code> <pre><code>def update_customer(self, id : int, customer : 'Customer') -&gt; \"customer\":\n    \"\"\"\n    Update an existing customer by ID.\n\n    Sends a PUT request to update a customer record using the provided customer data.\n\n    Args:\n        id (int): The ID of the customer to update.\n        customer (Customer): A Pydantic model representing the updated customer data.\n\n    Returns:\n        customer: A new Customer instance built from the updated response data.\n    \"\"\"\n    response = self.client._put(f\"/{self.endpoint}/{str(id)}\", json=customer.model_dump(exclude_none=True, exclude_unset=True))\n    return customer.from_json(response, self.client)\n</code></pre>"},{"location":"api/customers/#spyre.customers.customer","title":"<code>customer</code>","text":"<p>               Bases: <code>APIResource[Customer]</code></p> Source code in <code>src/spyre/customers.py</code> <pre><code>class customer(APIResource[Customer]):\n    endpoint = \"customers\"\n    Model = Customer\n\n\n    def delete(self) -&gt; bool:\n        \"\"\"\n        Deletes the Customer from Spire.\n\n        Sends a DELETE request to the API to remove the customer with the current ID.\n\n        Returns:\n            bool: True if the order was successfully deleted (HTTP 204 or 200), False otherwise.\n        \"\"\"\n        return self._client._delete(f\"/{self.endpoint}/{str(self.id)}\")\n\n    def update(self, customer: \"customer\" = None) -&gt; 'customer':\n        \"\"\"\n        Update the customer.\n\n        If no order object is provided, updates the current instance on the server.\n        If an order object is provided, updates the customer using the given data.\n\n        Args:\n            customer (customer, optional): An optional customer instance to use for the update.\n\n        Returns:\n            customer: The updated customer object reflecting the new status.\n        \"\"\"\n        data = customer.model_dump(exclude_unset=True, exclude_none=True) if customer else self.model_dump(exclude_unset=True, exclude_none=True)\n        response = self._client._put(f\"/{self.endpoint}/{str(self.id)}\", json=data)\n        return customer.from_json(response, self._client)\n</code></pre>"},{"location":"api/customers/#spyre.customers.customer.delete","title":"<code>delete()</code>","text":"<p>Deletes the Customer from Spire.</p> <p>Sends a DELETE request to the API to remove the customer with the current ID.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the order was successfully deleted (HTTP 204 or 200), False otherwise.</p> Source code in <code>src/spyre/customers.py</code> <pre><code>def delete(self) -&gt; bool:\n    \"\"\"\n    Deletes the Customer from Spire.\n\n    Sends a DELETE request to the API to remove the customer with the current ID.\n\n    Returns:\n        bool: True if the order was successfully deleted (HTTP 204 or 200), False otherwise.\n    \"\"\"\n    return self._client._delete(f\"/{self.endpoint}/{str(self.id)}\")\n</code></pre>"},{"location":"api/customers/#spyre.customers.customer.update","title":"<code>update(customer=None)</code>","text":"<p>Update the customer.</p> <p>If no order object is provided, updates the current instance on the server. If an order object is provided, updates the customer using the given data.</p> <p>Parameters:</p> Name Type Description Default <code>customer</code> <code>customer</code> <p>An optional customer instance to use for the update.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>customer</code> <code>customer</code> <p>The updated customer object reflecting the new status.</p> Source code in <code>src/spyre/customers.py</code> <pre><code>def update(self, customer: \"customer\" = None) -&gt; 'customer':\n    \"\"\"\n    Update the customer.\n\n    If no order object is provided, updates the current instance on the server.\n    If an order object is provided, updates the customer using the given data.\n\n    Args:\n        customer (customer, optional): An optional customer instance to use for the update.\n\n    Returns:\n        customer: The updated customer object reflecting the new status.\n    \"\"\"\n    data = customer.model_dump(exclude_unset=True, exclude_none=True) if customer else self.model_dump(exclude_unset=True, exclude_none=True)\n    response = self._client._put(f\"/{self.endpoint}/{str(self.id)}\", json=data)\n    return customer.from_json(response, self._client)\n</code></pre>"},{"location":"api/inventory/","title":"Inventory","text":""},{"location":"api/inventory/#spyre.inventory.ItemsClient","title":"<code>ItemsClient</code>","text":"Source code in <code>src/spyre/inventory.py</code> <pre><code>class ItemsClient():\n\n    def __init__(self, client : SpireClient):\n        self.client = client\n        self.endpoint = 'inventory/items'\n\n    def get_item(self, id: int = None, part_no: str = None, warehouse: str = None) -&gt; \"item\":\n        \"\"\"\n        Retrieve an inventory item by ID or (part_no + warehouse).\n\n        Sends a GET request to the Spire API to fetch inventory item data for the\n        specified ID, or uses a filtered query with part number and warehouse.\n        Wraps the result in an `item` instance, which retains a reference to the\n        client for further actions.\n\n        Args:\n            id (int, optional): The ID of the inventory item to retrieve.\n            part_no (str, optional): The part number of the item to retrieve.\n            warehouse (str, optional): The warehouse code where the item is located.\n\n        Returns:\n            item: An `item` wrapper instance containing the retrieved data.\n\n        Raises:\n            ValueError: If neither ID nor (part_no and warehouse) are provided,\n                        or if no matching item is found.\n        \"\"\"\n        if id is not None:\n            response = self.client._get(f\"/{self.endpoint}/{str(id)}\")\n            return item.from_json(response, self.client)\n\n        elif part_no and warehouse:\n            items = self.query_inventory_items(filter={\"partNo\": part_no, \"whse\": warehouse})\n            for itm in items:\n                if getattr(itm, \"partNo\", None) == part_no and getattr(itm, \"whse\", None) == warehouse:\n                    return itm\n            raise ValueError(f\"No item found with part_no='{part_no}' and warehouse='{warehouse}'.\")\n\n        else:\n            raise ValueError(\"You must provide either 'id' or both 'part_no' and 'warehouse'.\")\n\n    def create_item(self, item : 'InventoryItem') -&gt; 'item':\n        \"\"\"\n        Create a new Inventory Item in Spire.\n\n        Sends a POST request to the Inventory/Items endpoint .\n\n        Args:\n            item (dict): A InventoryItem instace containing the sales order details.\n\n        Returns:\n            item: The created InventoryItem instance.\n\n        Raises:\n            CreateRequestError: If the creation fails or response is invalid.\n        \"\"\"\n\n        response =  self.client._post(f\"/{self.endpoint}\", json=item.model_dump(exclude_unset=True, exclude_none=True))\n        if response.get('status_code') == 201:\n            location = response.get('headers').get('location')\n            parsed_url = urlparse(location)\n            path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n            id = path_segments[-1]\n            return self.get_item(id)\n        else:\n            error_message = response.get('content')\n            raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n\n\n    def update_item(self, id: int, inventory_item : 'InventoryItem') -&gt; \"item\":\n        \"\"\"\n        Update an existing Inventory Item by ID.\n\n        Sends a PUT request to the Inventory/Items endpoint with the provided data\n        to update the existing record. Returns a wrapped `item` object containing\n        the updated information.\n\n        Args:\n            id (int): The ID of the item to update.\n            inventory_item (InventoryItem): A InventoryItem instance with the sales order details.\n\n        Returns:\n            item: An instance of the item wrapper class initialized with \n                        the updated data and client session.\n        \"\"\"\n        response = self.client._put(f\"/{self.endpoint}/{str(id)}\", json=inventory_item.model_dump(exclude_none=True, exclude_unset=True))\n        return item.from_json(response, self.client)\n\n    def delete_item(self, id: int) -&gt; bool:\n        \"\"\"\n        Delete a inventory_item by its ID.\n\n        Sends a DELETE request to the endpoint to remove the specified\n        inventory item from the system.\n\n        Args:\n            id (int): The ID of the inventory item to delete.\n\n        Returns:\n            bool (bool): True if the item was successfully deleted, False otherwise.\n        \"\"\"\n        return self.client._delete(f\"/{self.endpoint}/{str(id)}\")\n\n\n    def query_inventory_items(\n        self,\n        *,\n        query: Optional[str] = None,\n        sort: Optional[Dict[str, str]] = None,\n        filter: Optional[Dict[str, Any]] = None,\n        all: bool = False,\n        limit: int = 1000,\n        start: int = 0,\n        **extra_params\n    ) -&gt; List[\"item\"]:\n        \"\"\"\n        Query inventory items with optional full-text search, filtering, multi-field sorting, and pagination.\n\n        Args:\n            query (str, optional): Full-text search string.\n            sort (dict, optional): Dictionary of sorting rules (e.g., {\"orderDate\": \"desc\", \"orderNo\": \"asc\"}).\n            filter (dict, optional): Dictionary of filters to apply (will be JSON-encoded and URL-safe).\n            all (bool, optional): If True, retrieves all pages of results.\n            limit (int, optional): Number of results per page (max 1000).\n            start (int, optional): Starting offset for pagination.\n            **extra_params (Any): Any additional parameters to include in the query.\n\n        Returns:\n            List[item]: List of wrapped sales order resources.\n        \"\"\"\n        return self.client._query(\n            endpoint=self.endpoint,\n            resource_cls=item,\n            query=query,\n            sort=sort,\n            filter=filter,\n            all=all,\n            limit=limit,\n            start=start,\n            **extra_params\n        )\n\n    def get_item_uoms(self, id : int) -&gt; List[\"uom\"]:\n        \"\"\"\n        Retrieve all Unit of Measure (UOM) entries for a specific inventory item.\n\n        This method sends a GET request to the Spire API to retrieve the unit of measure\n        records associated with the specified inventory item ID. Each returned record is \n        wrapped into a `uom` object, which includes the model and the client reference.\n\n        Args:\n            id (int): The unique identifier of the inventory item.\n\n        Returns:\n            List[uom]: A list of `uom` objects representing the UOM records for the item.\n        \"\"\"\n        uoms = []\n        response = self.client._get(f\"{self.endpoint}/{str(id)}/uoms\")\n        items = response.get('records')\n        for item in items:\n            uoms.append(uom.from_json(json_data=item, client = self.client, item_id = id))\n        return uoms\n\n    def get_uom(self, item_id :int , uom_id : int) -&gt; \"uom\":\n        \"\"\"\n        Retrieve a specific Unit of Measure (UOM) for a given inventory item.\n\n        This method sends a GET request to the Spire API to fetch a single UOM record\n        associated with a specific inventory item and UOM ID. The response is wrapped\n        into a `uom` object that maintains a reference to the API client.\n\n        Args:\n            item_id (int): The unique ID of the inventory item.\n            uom_id (int): The unique ID of the UOM to retrieve.\n\n        Returns:\n            uom: A `uom` object representing the retrieved unit of measure.\n\n        \"\"\"\n        response = self.client._get(f\"/{self.endpoint}/{str(item_id)}/uoms/{str(uom_id)}\")\n        return uom.from_json(response, self.client , item_id = item_id)\n\n\n    def create_item_uom(self, id: int, uom : UnitOfMeasure) -&gt; \"uom\":\n        \"\"\"\n        Create a new Unit of Measure (UOM) for a specific inventory item.\n\n        Sends a POST request to the Spire API to create a new UOM for the inventory item\n        with the specified ID. If successful, the method retrieves and returns the newly\n        created UOM object. If the creation fails, an exception is raised.\n\n        Args:\n            id (int): The ID of the inventory item for which to create the UOM.\n            uom (UnitOfMeasure): A Pydantic model instance representing the UOM to create.\n\n        Returns:\n            List[uom]: A list containing the created `uom` object.\n\n        Raises:\n            CreateRequestError: If the API response status is not 201 (Created).\n        \"\"\"\n        response =  self.client._post(f\"/{self.endpoint}/{str(id)}/uoms\", json=uom.model_dump(exclude_unset=True, exclude_none=True))\n        if response.get('status_code') == 201:\n            location = response.get('headers').get('location')\n            parsed_url = urlparse(location)\n            path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n            new_uom_id = path_segments[-1]\n            return self.get_uom(item_id=id, uom_id=new_uom_id)\n        else:\n            error_message = response.get('content')\n            raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n\n    def delete_uom(self, item_id : int, uom_id :int) -&gt; bool:\n        \"\"\"\n        Delete a Unit of Measure (UOM) from a specific inventory item.\n\n        Sends a DELETE request to the Spire API to remove a UOM associated with the\n        given item and UOM ID.\n\n        Args:\n            item_id (int): The ID of the inventory item.\n            uom_id (int): The ID of the Unit of Measure to delete.\n\n        Returns:\n            bool: True if the deletion was successful, otherwise raises an error.\n        \"\"\"\n        return self.client._delete(f\"/{self.endpoint}/{str(item_id)}/uoms/{str(uom_id)}\")\n\n    def update_item_uom(self, item_id: int, uom_id : int, uom_record :'uom') -&gt; 'uom':\n        \"\"\"\n        Update an existing Unit of Measure (UOM) for a given inventory item.\n\n        Sends a PUT request to the Spire API to update the UOM record with the specified\n        item and UOM ID using the provided `uom` data.\n\n        Args:\n            item_id (int): The ID of the inventory item.\n            uom_id (int): The ID of the UOM to update.\n            uom_record (uom): A `uom` instance with updated field values.\n\n        Returns:\n            uom: The updated `uom` instance returned from the API.\n        \"\"\"\n        response = self.client._put(f\"/{self.endpoint}/{str(item_id)}/uoms/{str(uom_id)}\", json=uom_record.model_dump(exclude_none=True, exclude_unset=True))\n        return uom.from_json(response, self.client, item_id = item_id)\n\n\n    def get_item_upcs(self, id : int) -&gt; List[\"upc\"]:\n        \"\"\"\n        Retrieve all UPC records associated with a specific inventory item.\n\n        Sends a GET request to the Spire API to fetch UPCs for the specified item ID,\n        then constructs and returns a list of `upc` objects.\n\n        Args:\n            id (int): The ID of the inventory item.\n\n        Returns:\n            List[upc]: A list of `upc` objects representing the item's UPC codes.\n        \"\"\"\n        upcs = []\n        response = self.client._get(f\"{self.endpoint}/{str(id)}/upcs\")\n        items = response.get('records')\n        for item in items:\n            upcs.append(upc.from_json(json_data=item, client = self.client, item_id = id))\n\n        return upcs\n\n    def get_upc(self, item_id :int , upc_id : int) -&gt; \"upc\":\n        \"\"\"\n        Retrieve a specific UPC (upc) for a given inventory item.\n\n        This method sends a GET request to the Spire API to fetch a single upc record\n        associated with a specific inventory item and upc ID. The response is wrapped\n        into a `upc` object that maintains a reference to the API client.\n\n        Args:\n            item_id (int): The unique ID of the inventory item.\n            upc_id (int): The unique ID of the upc to retrieve.\n\n        Returns:\n            upc: A `upc` object representing the retrieved unit of measure.\n\n        \"\"\"\n        response = self.client._get(f\"/{self.endpoint}/{str(item_id)}/upcs/{str(upc_id)}\")\n        return upc.from_json(response, self.client , item_id = item_id)\n\n    def create_item_upc(self, id: int, upc : UPC) -&gt; \"upc\":\n        \"\"\"\n        Create a new UPC (upc) for a specific inventory item.\n\n        Sends a POST request to the Spire API to create a new upc for the inventory item\n        with the specified ID. If successful, the method retrieves and returns the newly\n        created upc object. If the creation fails, an exception is raised.\n\n        Args:\n            id (int): The ID of the inventory item for which to create the upc.\n            upc (UPC): A Pydantic model instance representing the upc to create.\n\n        Returns:\n            List[upc]: A list containing the created `upc` object.\n\n        Raises:\n            CreateRequestError: If the API response status is not 201 (Created).\n        \"\"\"\n        response =  self.client._post(f\"/{self.endpoint}/{str(id)}/upcs\", json=upc.model_dump(exclude_unset=True, exclude_none=True))\n        if response.get('status_code') == 201:\n            location = response.get('headers').get('location')\n            parsed_url = urlparse(location)\n            path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n            new_upc_id = path_segments[-1]\n            return self.get_upc(item_id=id, upc_id = new_upc_id)\n        else:\n            error_message = response.get('content')\n            raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n\n    def delete_upc(self, item_id : int, upc_id :int) -&gt; bool:\n        \"\"\"\n        Delete a UPC (upc) from a specific inventory item.\n\n        Sends a DELETE request to the Spire API to remove a upc associated with the\n        given item and upc ID.\n\n        Args:\n            item_id (int): The ID of the inventory item.\n            upc_id (int): The ID of the Unit of Measure to delete.\n\n        Returns:\n            bool: True if the deletion was successful, otherwise raises an error.\n        \"\"\"\n        return self.client._delete(f\"/{self.endpoint}/{str(item_id)}/upcs/{str(upc_id)}\")\n\n    def update_item_upc(self, item_id: int, upc_id : int, upc_record :'upc') -&gt; 'upc':\n        \"\"\"\n        Update an existing UPC (upc) for a given inventory item.\n\n        Sends a PUT request to the Spire API to update the upc record with the specified\n        item and upc ID using the provided `upc` data.\n\n        Args:\n            item_id (int): The ID of the inventory item.\n            upc_id (int): The ID of the upc to update.\n            upc_record (upc): A `upc` instance with updated field values.\n\n        Returns:\n            upc: The updated `upc` instance returned from the API.\n        \"\"\"\n        response = self.client._put(f\"/{self.endpoint}/{str(item_id)}/upcs/{str(upc_id)}\", json=upc_record.model_dump(exclude_none=True, exclude_unset=True))\n        return upc.from_json(response, self.client, item_id = item_id)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.create_item","title":"<code>create_item(item)</code>","text":"<p>Create a new Inventory Item in Spire.</p> <p>Sends a POST request to the Inventory/Items endpoint .</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>dict</code> <p>A InventoryItem instace containing the sales order details.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>item</code> <p>The created InventoryItem instance.</p> <p>Raises:</p> Type Description <code>CreateRequestError</code> <p>If the creation fails or response is invalid.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def create_item(self, item : 'InventoryItem') -&gt; 'item':\n    \"\"\"\n    Create a new Inventory Item in Spire.\n\n    Sends a POST request to the Inventory/Items endpoint .\n\n    Args:\n        item (dict): A InventoryItem instace containing the sales order details.\n\n    Returns:\n        item: The created InventoryItem instance.\n\n    Raises:\n        CreateRequestError: If the creation fails or response is invalid.\n    \"\"\"\n\n    response =  self.client._post(f\"/{self.endpoint}\", json=item.model_dump(exclude_unset=True, exclude_none=True))\n    if response.get('status_code') == 201:\n        location = response.get('headers').get('location')\n        parsed_url = urlparse(location)\n        path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n        id = path_segments[-1]\n        return self.get_item(id)\n    else:\n        error_message = response.get('content')\n        raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.create_item_uom","title":"<code>create_item_uom(id, uom)</code>","text":"<p>Create a new Unit of Measure (UOM) for a specific inventory item.</p> <p>Sends a POST request to the Spire API to create a new UOM for the inventory item with the specified ID. If successful, the method retrieves and returns the newly created UOM object. If the creation fails, an exception is raised.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the inventory item for which to create the UOM.</p> required <code>uom</code> <code>UnitOfMeasure</code> <p>A Pydantic model instance representing the UOM to create.</p> required <p>Returns:</p> Type Description <code>uom</code> <p>List[uom]: A list containing the created <code>uom</code> object.</p> <p>Raises:</p> Type Description <code>CreateRequestError</code> <p>If the API response status is not 201 (Created).</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def create_item_uom(self, id: int, uom : UnitOfMeasure) -&gt; \"uom\":\n    \"\"\"\n    Create a new Unit of Measure (UOM) for a specific inventory item.\n\n    Sends a POST request to the Spire API to create a new UOM for the inventory item\n    with the specified ID. If successful, the method retrieves and returns the newly\n    created UOM object. If the creation fails, an exception is raised.\n\n    Args:\n        id (int): The ID of the inventory item for which to create the UOM.\n        uom (UnitOfMeasure): A Pydantic model instance representing the UOM to create.\n\n    Returns:\n        List[uom]: A list containing the created `uom` object.\n\n    Raises:\n        CreateRequestError: If the API response status is not 201 (Created).\n    \"\"\"\n    response =  self.client._post(f\"/{self.endpoint}/{str(id)}/uoms\", json=uom.model_dump(exclude_unset=True, exclude_none=True))\n    if response.get('status_code') == 201:\n        location = response.get('headers').get('location')\n        parsed_url = urlparse(location)\n        path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n        new_uom_id = path_segments[-1]\n        return self.get_uom(item_id=id, uom_id=new_uom_id)\n    else:\n        error_message = response.get('content')\n        raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.create_item_upc","title":"<code>create_item_upc(id, upc)</code>","text":"<p>Create a new UPC (upc) for a specific inventory item.</p> <p>Sends a POST request to the Spire API to create a new upc for the inventory item with the specified ID. If successful, the method retrieves and returns the newly created upc object. If the creation fails, an exception is raised.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the inventory item for which to create the upc.</p> required <code>upc</code> <code>UPC</code> <p>A Pydantic model instance representing the upc to create.</p> required <p>Returns:</p> Type Description <code>upc</code> <p>List[upc]: A list containing the created <code>upc</code> object.</p> <p>Raises:</p> Type Description <code>CreateRequestError</code> <p>If the API response status is not 201 (Created).</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def create_item_upc(self, id: int, upc : UPC) -&gt; \"upc\":\n    \"\"\"\n    Create a new UPC (upc) for a specific inventory item.\n\n    Sends a POST request to the Spire API to create a new upc for the inventory item\n    with the specified ID. If successful, the method retrieves and returns the newly\n    created upc object. If the creation fails, an exception is raised.\n\n    Args:\n        id (int): The ID of the inventory item for which to create the upc.\n        upc (UPC): A Pydantic model instance representing the upc to create.\n\n    Returns:\n        List[upc]: A list containing the created `upc` object.\n\n    Raises:\n        CreateRequestError: If the API response status is not 201 (Created).\n    \"\"\"\n    response =  self.client._post(f\"/{self.endpoint}/{str(id)}/upcs\", json=upc.model_dump(exclude_unset=True, exclude_none=True))\n    if response.get('status_code') == 201:\n        location = response.get('headers').get('location')\n        parsed_url = urlparse(location)\n        path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n        new_upc_id = path_segments[-1]\n        return self.get_upc(item_id=id, upc_id = new_upc_id)\n    else:\n        error_message = response.get('content')\n        raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.delete_item","title":"<code>delete_item(id)</code>","text":"<p>Delete a inventory_item by its ID.</p> <p>Sends a DELETE request to the endpoint to remove the specified inventory item from the system.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the inventory item to delete.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the item was successfully deleted, False otherwise.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def delete_item(self, id: int) -&gt; bool:\n    \"\"\"\n    Delete a inventory_item by its ID.\n\n    Sends a DELETE request to the endpoint to remove the specified\n    inventory item from the system.\n\n    Args:\n        id (int): The ID of the inventory item to delete.\n\n    Returns:\n        bool (bool): True if the item was successfully deleted, False otherwise.\n    \"\"\"\n    return self.client._delete(f\"/{self.endpoint}/{str(id)}\")\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.delete_uom","title":"<code>delete_uom(item_id, uom_id)</code>","text":"<p>Delete a Unit of Measure (UOM) from a specific inventory item.</p> <p>Sends a DELETE request to the Spire API to remove a UOM associated with the given item and UOM ID.</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>int</code> <p>The ID of the inventory item.</p> required <code>uom_id</code> <code>int</code> <p>The ID of the Unit of Measure to delete.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the deletion was successful, otherwise raises an error.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def delete_uom(self, item_id : int, uom_id :int) -&gt; bool:\n    \"\"\"\n    Delete a Unit of Measure (UOM) from a specific inventory item.\n\n    Sends a DELETE request to the Spire API to remove a UOM associated with the\n    given item and UOM ID.\n\n    Args:\n        item_id (int): The ID of the inventory item.\n        uom_id (int): The ID of the Unit of Measure to delete.\n\n    Returns:\n        bool: True if the deletion was successful, otherwise raises an error.\n    \"\"\"\n    return self.client._delete(f\"/{self.endpoint}/{str(item_id)}/uoms/{str(uom_id)}\")\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.delete_upc","title":"<code>delete_upc(item_id, upc_id)</code>","text":"<p>Delete a UPC (upc) from a specific inventory item.</p> <p>Sends a DELETE request to the Spire API to remove a upc associated with the given item and upc ID.</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>int</code> <p>The ID of the inventory item.</p> required <code>upc_id</code> <code>int</code> <p>The ID of the Unit of Measure to delete.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the deletion was successful, otherwise raises an error.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def delete_upc(self, item_id : int, upc_id :int) -&gt; bool:\n    \"\"\"\n    Delete a UPC (upc) from a specific inventory item.\n\n    Sends a DELETE request to the Spire API to remove a upc associated with the\n    given item and upc ID.\n\n    Args:\n        item_id (int): The ID of the inventory item.\n        upc_id (int): The ID of the Unit of Measure to delete.\n\n    Returns:\n        bool: True if the deletion was successful, otherwise raises an error.\n    \"\"\"\n    return self.client._delete(f\"/{self.endpoint}/{str(item_id)}/upcs/{str(upc_id)}\")\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.get_item","title":"<code>get_item(id=None, part_no=None, warehouse=None)</code>","text":"<p>Retrieve an inventory item by ID or (part_no + warehouse).</p> <p>Sends a GET request to the Spire API to fetch inventory item data for the specified ID, or uses a filtered query with part number and warehouse. Wraps the result in an <code>item</code> instance, which retains a reference to the client for further actions.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the inventory item to retrieve.</p> <code>None</code> <code>part_no</code> <code>str</code> <p>The part number of the item to retrieve.</p> <code>None</code> <code>warehouse</code> <code>str</code> <p>The warehouse code where the item is located.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>item</code> <code>item</code> <p>An <code>item</code> wrapper instance containing the retrieved data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither ID nor (part_no and warehouse) are provided,         or if no matching item is found.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def get_item(self, id: int = None, part_no: str = None, warehouse: str = None) -&gt; \"item\":\n    \"\"\"\n    Retrieve an inventory item by ID or (part_no + warehouse).\n\n    Sends a GET request to the Spire API to fetch inventory item data for the\n    specified ID, or uses a filtered query with part number and warehouse.\n    Wraps the result in an `item` instance, which retains a reference to the\n    client for further actions.\n\n    Args:\n        id (int, optional): The ID of the inventory item to retrieve.\n        part_no (str, optional): The part number of the item to retrieve.\n        warehouse (str, optional): The warehouse code where the item is located.\n\n    Returns:\n        item: An `item` wrapper instance containing the retrieved data.\n\n    Raises:\n        ValueError: If neither ID nor (part_no and warehouse) are provided,\n                    or if no matching item is found.\n    \"\"\"\n    if id is not None:\n        response = self.client._get(f\"/{self.endpoint}/{str(id)}\")\n        return item.from_json(response, self.client)\n\n    elif part_no and warehouse:\n        items = self.query_inventory_items(filter={\"partNo\": part_no, \"whse\": warehouse})\n        for itm in items:\n            if getattr(itm, \"partNo\", None) == part_no and getattr(itm, \"whse\", None) == warehouse:\n                return itm\n        raise ValueError(f\"No item found with part_no='{part_no}' and warehouse='{warehouse}'.\")\n\n    else:\n        raise ValueError(\"You must provide either 'id' or both 'part_no' and 'warehouse'.\")\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.get_item_uoms","title":"<code>get_item_uoms(id)</code>","text":"<p>Retrieve all Unit of Measure (UOM) entries for a specific inventory item.</p> <p>This method sends a GET request to the Spire API to retrieve the unit of measure records associated with the specified inventory item ID. Each returned record is  wrapped into a <code>uom</code> object, which includes the model and the client reference.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The unique identifier of the inventory item.</p> required <p>Returns:</p> Type Description <code>List[uom]</code> <p>List[uom]: A list of <code>uom</code> objects representing the UOM records for the item.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def get_item_uoms(self, id : int) -&gt; List[\"uom\"]:\n    \"\"\"\n    Retrieve all Unit of Measure (UOM) entries for a specific inventory item.\n\n    This method sends a GET request to the Spire API to retrieve the unit of measure\n    records associated with the specified inventory item ID. Each returned record is \n    wrapped into a `uom` object, which includes the model and the client reference.\n\n    Args:\n        id (int): The unique identifier of the inventory item.\n\n    Returns:\n        List[uom]: A list of `uom` objects representing the UOM records for the item.\n    \"\"\"\n    uoms = []\n    response = self.client._get(f\"{self.endpoint}/{str(id)}/uoms\")\n    items = response.get('records')\n    for item in items:\n        uoms.append(uom.from_json(json_data=item, client = self.client, item_id = id))\n    return uoms\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.get_item_upcs","title":"<code>get_item_upcs(id)</code>","text":"<p>Retrieve all UPC records associated with a specific inventory item.</p> <p>Sends a GET request to the Spire API to fetch UPCs for the specified item ID, then constructs and returns a list of <code>upc</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the inventory item.</p> required <p>Returns:</p> Type Description <code>List[upc]</code> <p>List[upc]: A list of <code>upc</code> objects representing the item's UPC codes.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def get_item_upcs(self, id : int) -&gt; List[\"upc\"]:\n    \"\"\"\n    Retrieve all UPC records associated with a specific inventory item.\n\n    Sends a GET request to the Spire API to fetch UPCs for the specified item ID,\n    then constructs and returns a list of `upc` objects.\n\n    Args:\n        id (int): The ID of the inventory item.\n\n    Returns:\n        List[upc]: A list of `upc` objects representing the item's UPC codes.\n    \"\"\"\n    upcs = []\n    response = self.client._get(f\"{self.endpoint}/{str(id)}/upcs\")\n    items = response.get('records')\n    for item in items:\n        upcs.append(upc.from_json(json_data=item, client = self.client, item_id = id))\n\n    return upcs\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.get_uom","title":"<code>get_uom(item_id, uom_id)</code>","text":"<p>Retrieve a specific Unit of Measure (UOM) for a given inventory item.</p> <p>This method sends a GET request to the Spire API to fetch a single UOM record associated with a specific inventory item and UOM ID. The response is wrapped into a <code>uom</code> object that maintains a reference to the API client.</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>int</code> <p>The unique ID of the inventory item.</p> required <code>uom_id</code> <code>int</code> <p>The unique ID of the UOM to retrieve.</p> required <p>Returns:</p> Name Type Description <code>uom</code> <code>uom</code> <p>A <code>uom</code> object representing the retrieved unit of measure.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def get_uom(self, item_id :int , uom_id : int) -&gt; \"uom\":\n    \"\"\"\n    Retrieve a specific Unit of Measure (UOM) for a given inventory item.\n\n    This method sends a GET request to the Spire API to fetch a single UOM record\n    associated with a specific inventory item and UOM ID. The response is wrapped\n    into a `uom` object that maintains a reference to the API client.\n\n    Args:\n        item_id (int): The unique ID of the inventory item.\n        uom_id (int): The unique ID of the UOM to retrieve.\n\n    Returns:\n        uom: A `uom` object representing the retrieved unit of measure.\n\n    \"\"\"\n    response = self.client._get(f\"/{self.endpoint}/{str(item_id)}/uoms/{str(uom_id)}\")\n    return uom.from_json(response, self.client , item_id = item_id)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.get_upc","title":"<code>get_upc(item_id, upc_id)</code>","text":"<p>Retrieve a specific UPC (upc) for a given inventory item.</p> <p>This method sends a GET request to the Spire API to fetch a single upc record associated with a specific inventory item and upc ID. The response is wrapped into a <code>upc</code> object that maintains a reference to the API client.</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>int</code> <p>The unique ID of the inventory item.</p> required <code>upc_id</code> <code>int</code> <p>The unique ID of the upc to retrieve.</p> required <p>Returns:</p> Name Type Description <code>upc</code> <code>upc</code> <p>A <code>upc</code> object representing the retrieved unit of measure.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def get_upc(self, item_id :int , upc_id : int) -&gt; \"upc\":\n    \"\"\"\n    Retrieve a specific UPC (upc) for a given inventory item.\n\n    This method sends a GET request to the Spire API to fetch a single upc record\n    associated with a specific inventory item and upc ID. The response is wrapped\n    into a `upc` object that maintains a reference to the API client.\n\n    Args:\n        item_id (int): The unique ID of the inventory item.\n        upc_id (int): The unique ID of the upc to retrieve.\n\n    Returns:\n        upc: A `upc` object representing the retrieved unit of measure.\n\n    \"\"\"\n    response = self.client._get(f\"/{self.endpoint}/{str(item_id)}/upcs/{str(upc_id)}\")\n    return upc.from_json(response, self.client , item_id = item_id)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.query_inventory_items","title":"<code>query_inventory_items(*, query=None, sort=None, filter=None, all=False, limit=1000, start=0, **extra_params)</code>","text":"<p>Query inventory items with optional full-text search, filtering, multi-field sorting, and pagination.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Full-text search string.</p> <code>None</code> <code>sort</code> <code>dict</code> <p>Dictionary of sorting rules (e.g., {\"orderDate\": \"desc\", \"orderNo\": \"asc\"}).</p> <code>None</code> <code>filter</code> <code>dict</code> <p>Dictionary of filters to apply (will be JSON-encoded and URL-safe).</p> <code>None</code> <code>all</code> <code>bool</code> <p>If True, retrieves all pages of results.</p> <code>False</code> <code>limit</code> <code>int</code> <p>Number of results per page (max 1000).</p> <code>1000</code> <code>start</code> <code>int</code> <p>Starting offset for pagination.</p> <code>0</code> <code>**extra_params</code> <code>Any</code> <p>Any additional parameters to include in the query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[item]</code> <p>List[item]: List of wrapped sales order resources.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def query_inventory_items(\n    self,\n    *,\n    query: Optional[str] = None,\n    sort: Optional[Dict[str, str]] = None,\n    filter: Optional[Dict[str, Any]] = None,\n    all: bool = False,\n    limit: int = 1000,\n    start: int = 0,\n    **extra_params\n) -&gt; List[\"item\"]:\n    \"\"\"\n    Query inventory items with optional full-text search, filtering, multi-field sorting, and pagination.\n\n    Args:\n        query (str, optional): Full-text search string.\n        sort (dict, optional): Dictionary of sorting rules (e.g., {\"orderDate\": \"desc\", \"orderNo\": \"asc\"}).\n        filter (dict, optional): Dictionary of filters to apply (will be JSON-encoded and URL-safe).\n        all (bool, optional): If True, retrieves all pages of results.\n        limit (int, optional): Number of results per page (max 1000).\n        start (int, optional): Starting offset for pagination.\n        **extra_params (Any): Any additional parameters to include in the query.\n\n    Returns:\n        List[item]: List of wrapped sales order resources.\n    \"\"\"\n    return self.client._query(\n        endpoint=self.endpoint,\n        resource_cls=item,\n        query=query,\n        sort=sort,\n        filter=filter,\n        all=all,\n        limit=limit,\n        start=start,\n        **extra_params\n    )\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.update_item","title":"<code>update_item(id, inventory_item)</code>","text":"<p>Update an existing Inventory Item by ID.</p> <p>Sends a PUT request to the Inventory/Items endpoint with the provided data to update the existing record. Returns a wrapped <code>item</code> object containing the updated information.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the item to update.</p> required <code>inventory_item</code> <code>InventoryItem</code> <p>A InventoryItem instance with the sales order details.</p> required <p>Returns:</p> Name Type Description <code>item</code> <code>item</code> <p>An instance of the item wrapper class initialized with          the updated data and client session.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def update_item(self, id: int, inventory_item : 'InventoryItem') -&gt; \"item\":\n    \"\"\"\n    Update an existing Inventory Item by ID.\n\n    Sends a PUT request to the Inventory/Items endpoint with the provided data\n    to update the existing record. Returns a wrapped `item` object containing\n    the updated information.\n\n    Args:\n        id (int): The ID of the item to update.\n        inventory_item (InventoryItem): A InventoryItem instance with the sales order details.\n\n    Returns:\n        item: An instance of the item wrapper class initialized with \n                    the updated data and client session.\n    \"\"\"\n    response = self.client._put(f\"/{self.endpoint}/{str(id)}\", json=inventory_item.model_dump(exclude_none=True, exclude_unset=True))\n    return item.from_json(response, self.client)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.update_item_uom","title":"<code>update_item_uom(item_id, uom_id, uom_record)</code>","text":"<p>Update an existing Unit of Measure (UOM) for a given inventory item.</p> <p>Sends a PUT request to the Spire API to update the UOM record with the specified item and UOM ID using the provided <code>uom</code> data.</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>int</code> <p>The ID of the inventory item.</p> required <code>uom_id</code> <code>int</code> <p>The ID of the UOM to update.</p> required <code>uom_record</code> <code>uom</code> <p>A <code>uom</code> instance with updated field values.</p> required <p>Returns:</p> Name Type Description <code>uom</code> <code>uom</code> <p>The updated <code>uom</code> instance returned from the API.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def update_item_uom(self, item_id: int, uom_id : int, uom_record :'uom') -&gt; 'uom':\n    \"\"\"\n    Update an existing Unit of Measure (UOM) for a given inventory item.\n\n    Sends a PUT request to the Spire API to update the UOM record with the specified\n    item and UOM ID using the provided `uom` data.\n\n    Args:\n        item_id (int): The ID of the inventory item.\n        uom_id (int): The ID of the UOM to update.\n        uom_record (uom): A `uom` instance with updated field values.\n\n    Returns:\n        uom: The updated `uom` instance returned from the API.\n    \"\"\"\n    response = self.client._put(f\"/{self.endpoint}/{str(item_id)}/uoms/{str(uom_id)}\", json=uom_record.model_dump(exclude_none=True, exclude_unset=True))\n    return uom.from_json(response, self.client, item_id = item_id)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.ItemsClient.update_item_upc","title":"<code>update_item_upc(item_id, upc_id, upc_record)</code>","text":"<p>Update an existing UPC (upc) for a given inventory item.</p> <p>Sends a PUT request to the Spire API to update the upc record with the specified item and upc ID using the provided <code>upc</code> data.</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>int</code> <p>The ID of the inventory item.</p> required <code>upc_id</code> <code>int</code> <p>The ID of the upc to update.</p> required <code>upc_record</code> <code>upc</code> <p>A <code>upc</code> instance with updated field values.</p> required <p>Returns:</p> Name Type Description <code>upc</code> <code>upc</code> <p>The updated <code>upc</code> instance returned from the API.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def update_item_upc(self, item_id: int, upc_id : int, upc_record :'upc') -&gt; 'upc':\n    \"\"\"\n    Update an existing UPC (upc) for a given inventory item.\n\n    Sends a PUT request to the Spire API to update the upc record with the specified\n    item and upc ID using the provided `upc` data.\n\n    Args:\n        item_id (int): The ID of the inventory item.\n        upc_id (int): The ID of the upc to update.\n        upc_record (upc): A `upc` instance with updated field values.\n\n    Returns:\n        upc: The updated `upc` instance returned from the API.\n    \"\"\"\n    response = self.client._put(f\"/{self.endpoint}/{str(item_id)}/upcs/{str(upc_id)}\", json=upc_record.model_dump(exclude_none=True, exclude_unset=True))\n    return upc.from_json(response, self.client, item_id = item_id)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.UpcClient","title":"<code>UpcClient</code>","text":"Source code in <code>src/spyre/inventory.py</code> <pre><code>class UpcClient():\n\n    def __init__(self, client : SpireClient):\n        self.endpoint = 'inventory/upcs'\n        self.client = client\n\n    def get_upc(self, upc_id : int) -&gt; \"upc\":\n        \"\"\"\n        Retrieve a specific UPC (upc) for given id.\n\n        This method sends a GET request to the Spire API to fetch a single upc record\n        associated with the upc ID. The response is wrapped\n        into a `upc` object that maintains a reference to the API client.\n\n        Args:\n            upc_id (int): The unique ID of the upc to retrieve.\n\n        Returns:\n            upc: A `upc` object representing the retrieved unit of measure.\n\n        \"\"\"\n        response = self.client._get(f\"/{self.endpoint}/{str(upc_id)}\")\n        return upc.from_json(response, self.client)\n\n    def create_item_upc(self, upc : UPC) -&gt; \"upc\":\n        \"\"\"\n        Create a new UPC (upc) for a given id.\n\n        Sends a POST request to the Spire API to create a new upc.\n        If successful, the method retrieves and returns the newly\n        created upc object. If the creation fails, an exception is raised.\n        For a successful creation, either the whse and the partNo or the inventory\n        field has to be filled in\n\n        Args:\n            upc (UPC): A Pydantic model instance representing the upc to create.\n\n        Returns:\n            upc (upc): A list containing the created `upc` object.\n\n        Raises:\n            CreateRequestError: If the API response status is not 201 (Created).\n        \"\"\"\n        response =  self.client._post(f\"/{self.endpoint}/{str(id)}\", json=upc.model_dump(exclude_unset=True, exclude_none=True))\n        if response.get('status_code') == 201:\n            location = response.get('headers').get('location')\n            parsed_url = urlparse(location)\n            path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n            new_upc_id = path_segments[-1]\n            return self.get_upc(upc_id = new_upc_id)\n        else:\n            error_message = response.get('content')\n            raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n\n    def delete_upc(self, upc_id :int) -&gt; bool:\n        \"\"\"\n        Delete a UPC.\n\n        Sends a DELETE request to the Spire API to remove a upc associated with the\n        given upc ID.\n\n        Args:\n            upc_id (int): The ID of the Unit of Measure to delete.\n\n        Returns:\n            bool: True if the deletion was successful, otherwise raises an error.\n        \"\"\"\n        return self.client._delete(f\"/{self.endpoint}/{str(upc_id)}\")\n\n    def update_item_upc(self, upc_id : int, upc_record :'upc') -&gt; 'upc':\n        \"\"\"\n        Update an existing UPC.\n\n        Sends a PUT request to the Spire API to update the upc record with the specified\n        upc ID using the provided `upc` data.\n\n        Args:\n            upc_id (int): The ID of the upc to update.\n            upc_record (upc): A `upc` instance with updated field values.\n\n        Returns:\n            upc: The updated `upc` instance returned from the API.\n        \"\"\"\n        response = self.client._put(f\"/{self.endpoint}/{str(upc_id)}\", json=upc_record.model_dump(exclude_none=True, exclude_unset=True))\n        return upc.from_json(response, self.client)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.UpcClient.create_item_upc","title":"<code>create_item_upc(upc)</code>","text":"<p>Create a new UPC (upc) for a given id.</p> <p>Sends a POST request to the Spire API to create a new upc. If successful, the method retrieves and returns the newly created upc object. If the creation fails, an exception is raised. For a successful creation, either the whse and the partNo or the inventory field has to be filled in</p> <p>Parameters:</p> Name Type Description Default <code>upc</code> <code>UPC</code> <p>A Pydantic model instance representing the upc to create.</p> required <p>Returns:</p> Name Type Description <code>upc</code> <code>upc</code> <p>A list containing the created <code>upc</code> object.</p> <p>Raises:</p> Type Description <code>CreateRequestError</code> <p>If the API response status is not 201 (Created).</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def create_item_upc(self, upc : UPC) -&gt; \"upc\":\n    \"\"\"\n    Create a new UPC (upc) for a given id.\n\n    Sends a POST request to the Spire API to create a new upc.\n    If successful, the method retrieves and returns the newly\n    created upc object. If the creation fails, an exception is raised.\n    For a successful creation, either the whse and the partNo or the inventory\n    field has to be filled in\n\n    Args:\n        upc (UPC): A Pydantic model instance representing the upc to create.\n\n    Returns:\n        upc (upc): A list containing the created `upc` object.\n\n    Raises:\n        CreateRequestError: If the API response status is not 201 (Created).\n    \"\"\"\n    response =  self.client._post(f\"/{self.endpoint}/{str(id)}\", json=upc.model_dump(exclude_unset=True, exclude_none=True))\n    if response.get('status_code') == 201:\n        location = response.get('headers').get('location')\n        parsed_url = urlparse(location)\n        path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n        new_upc_id = path_segments[-1]\n        return self.get_upc(upc_id = new_upc_id)\n    else:\n        error_message = response.get('content')\n        raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.UpcClient.delete_upc","title":"<code>delete_upc(upc_id)</code>","text":"<p>Delete a UPC.</p> <p>Sends a DELETE request to the Spire API to remove a upc associated with the given upc ID.</p> <p>Parameters:</p> Name Type Description Default <code>upc_id</code> <code>int</code> <p>The ID of the Unit of Measure to delete.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the deletion was successful, otherwise raises an error.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def delete_upc(self, upc_id :int) -&gt; bool:\n    \"\"\"\n    Delete a UPC.\n\n    Sends a DELETE request to the Spire API to remove a upc associated with the\n    given upc ID.\n\n    Args:\n        upc_id (int): The ID of the Unit of Measure to delete.\n\n    Returns:\n        bool: True if the deletion was successful, otherwise raises an error.\n    \"\"\"\n    return self.client._delete(f\"/{self.endpoint}/{str(upc_id)}\")\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.UpcClient.get_upc","title":"<code>get_upc(upc_id)</code>","text":"<p>Retrieve a specific UPC (upc) for given id.</p> <p>This method sends a GET request to the Spire API to fetch a single upc record associated with the upc ID. The response is wrapped into a <code>upc</code> object that maintains a reference to the API client.</p> <p>Parameters:</p> Name Type Description Default <code>upc_id</code> <code>int</code> <p>The unique ID of the upc to retrieve.</p> required <p>Returns:</p> Name Type Description <code>upc</code> <code>upc</code> <p>A <code>upc</code> object representing the retrieved unit of measure.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def get_upc(self, upc_id : int) -&gt; \"upc\":\n    \"\"\"\n    Retrieve a specific UPC (upc) for given id.\n\n    This method sends a GET request to the Spire API to fetch a single upc record\n    associated with the upc ID. The response is wrapped\n    into a `upc` object that maintains a reference to the API client.\n\n    Args:\n        upc_id (int): The unique ID of the upc to retrieve.\n\n    Returns:\n        upc: A `upc` object representing the retrieved unit of measure.\n\n    \"\"\"\n    response = self.client._get(f\"/{self.endpoint}/{str(upc_id)}\")\n    return upc.from_json(response, self.client)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.UpcClient.update_item_upc","title":"<code>update_item_upc(upc_id, upc_record)</code>","text":"<p>Update an existing UPC.</p> <p>Sends a PUT request to the Spire API to update the upc record with the specified upc ID using the provided <code>upc</code> data.</p> <p>Parameters:</p> Name Type Description Default <code>upc_id</code> <code>int</code> <p>The ID of the upc to update.</p> required <code>upc_record</code> <code>upc</code> <p>A <code>upc</code> instance with updated field values.</p> required <p>Returns:</p> Name Type Description <code>upc</code> <code>upc</code> <p>The updated <code>upc</code> instance returned from the API.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def update_item_upc(self, upc_id : int, upc_record :'upc') -&gt; 'upc':\n    \"\"\"\n    Update an existing UPC.\n\n    Sends a PUT request to the Spire API to update the upc record with the specified\n    upc ID using the provided `upc` data.\n\n    Args:\n        upc_id (int): The ID of the upc to update.\n        upc_record (upc): A `upc` instance with updated field values.\n\n    Returns:\n        upc: The updated `upc` instance returned from the API.\n    \"\"\"\n    response = self.client._put(f\"/{self.endpoint}/{str(upc_id)}\", json=upc_record.model_dump(exclude_none=True, exclude_unset=True))\n    return upc.from_json(response, self.client)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.item","title":"<code>item</code>","text":"<p>               Bases: <code>APIResource[InventoryItem]</code></p> Source code in <code>src/spyre/inventory.py</code> <pre><code>class item(APIResource[InventoryItem]):\n\n    endpoint =  'inventory/items'\n    Model = InventoryItem\n\n    def delete(self) -&gt; bool:\n        \"\"\"\n        Cancels or deletes the item.\n\n        Sends a DELETE request to the API to remove the inventory item with the current ID.\n\n        Returns:\n            bool: True if the order was successfully deleted (HTTP 204 or 200), False otherwise.\n        \"\"\"\n\n        return self._client._delete(f\"/{self.endpoint}/{str(self.id)}\")\n\n    def update(self, inventory_item: \"item\" = None) -&gt; 'item':\n        \"\"\"\n        Update the inventory item.\n\n        If no item object is provided, updates the current instance on the server.\n        If an item object is provided, updates the item using the given data.\n\n        Args:\n            inventory_item (item, optional): An optional item instance to use for the update.\n\n        Returns:\n            item: The updated item object reflecting the new status.\n        \"\"\"\n        data = inventory_item.model_dump(exclude_unset=True, exclude_none=True) if inventory_item else self.model_dump(exclude_unset=True, exclude_none=True)\n        response = self._client._put(f\"/{self.endpoint}/{str(self.id)}\", json=data)\n        return item.from_json(response, self._client)    \n\n    def get_uoms(self) -&gt; List[\"uom\"]:\n        \"\"\"\n        Retrieve all Unit of Measure (UOM) records for the current inventory item.\n\n        This method sends a GET request to the Spire API and returns all UOMs\n        associated with this item's ID.\n\n        Returns:\n            List[uom]: A list of `uom` instances representing the available units of measure.\n        \"\"\"       \n        uoms = []\n        response = self._client._get(f\"{self.endpoint}/{self.id}/uoms\")\n        items = response.get('records')\n        for item in items:\n            uoms.append(uom.from_json(json_data=item, client = self._client, item_id = self.id))\n\n        return uoms\n\n    def get_upcs(self) -&gt; List[\"upc\"]:\n        \"\"\"\n        Retrieve all UPC records for the current inventory item.\n\n        This method sends a GET request to the Spire API and returns all UPCs\n        associated with this item's ID.\n\n        Returns:\n            List[upc]: A list of `upc` instances representing the available units of measure.\n        \"\"\"     \n        upcs = []\n        response = self._client._get(f\"{self.endpoint}/{self.id}/upcs\")\n        items = response.get('records')\n        for item in items:\n            upcs.append(upc.from_json(json_data=item, client = self._client, item_id = id))\n\n        return upcs\n\n    def add_uom(self, uom_record : UnitOfMeasure) -&gt; \"uom\":\n        \"\"\"\n        Add a new Unit of Measure (UOM) to the current inventory item.\n\n        Sends a POST request to the Spire API to create a new UOM record using the provided\n        `UnitOfMeasure` model. If the creation is successful (HTTP 201), it retrieves\n        and returns the created UOM.\n\n        Args:\n            uom_record (UnitOfMeasure): The UnitOfMeasure Pydantic model to be created.\n\n        Returns:\n            uom (uom): The newly created Unit of measure as a `uom` instance.\n\n        Raises:\n            CreateRequestError: If the API returns a non-201 status code during creation.\n        \"\"\"\n        response =  self._client._post(f\"/{self.endpoint}/{str(self.id)}/uoms\", json=uom_record.model_dump(exclude_unset=True, exclude_none=True))\n        if response.get('status_code') == 201:\n            location = response.get('headers').get('location')\n            parsed_url = urlparse(location)\n            path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n            id = path_segments[-1]\n            return InventoryClient(self._client).items.get_uom(id)\n        else:\n            error_message = response.get('content')\n            raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n\n    def add_upc(self, upc_record : UPC) -&gt; \"upc\":\n        \"\"\"\n        Add a new UPC to the current inventory item.\n\n        Sends a POST request to the Spire API to create a new UPC record using the provided\n        UPC model. If the creation is successful (HTTP 201), it retrieves\n        and returns the created UPC.\n\n        Args:\n            upc_record (UPC): The UPC Pydantic model to be created.\n\n        Returns:\n            upc (upc): The newly created UPC as a `upc` instance.\n\n        Raises:\n            CreateRequestError: If the API returns a non-201 status code during creation.\n        \"\"\"\n        response =  self._client._post(f\"/{self.endpoint}/{str(self.id)}/upcs\", json=upc_record.model_dump(exclude_unset=True, exclude_none=True))\n        if response.get('status_code') == 201:\n            location = response.get('headers').get('location')\n            parsed_url = urlparse(location)\n            path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n            id = path_segments[-1]\n            return InventoryClient(self._client).items.get_upc(id)\n        else:\n            error_message = response.get('content')\n            raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.item.add_uom","title":"<code>add_uom(uom_record)</code>","text":"<p>Add a new Unit of Measure (UOM) to the current inventory item.</p> <p>Sends a POST request to the Spire API to create a new UOM record using the provided <code>UnitOfMeasure</code> model. If the creation is successful (HTTP 201), it retrieves and returns the created UOM.</p> <p>Parameters:</p> Name Type Description Default <code>uom_record</code> <code>UnitOfMeasure</code> <p>The UnitOfMeasure Pydantic model to be created.</p> required <p>Returns:</p> Name Type Description <code>uom</code> <code>uom</code> <p>The newly created Unit of measure as a <code>uom</code> instance.</p> <p>Raises:</p> Type Description <code>CreateRequestError</code> <p>If the API returns a non-201 status code during creation.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def add_uom(self, uom_record : UnitOfMeasure) -&gt; \"uom\":\n    \"\"\"\n    Add a new Unit of Measure (UOM) to the current inventory item.\n\n    Sends a POST request to the Spire API to create a new UOM record using the provided\n    `UnitOfMeasure` model. If the creation is successful (HTTP 201), it retrieves\n    and returns the created UOM.\n\n    Args:\n        uom_record (UnitOfMeasure): The UnitOfMeasure Pydantic model to be created.\n\n    Returns:\n        uom (uom): The newly created Unit of measure as a `uom` instance.\n\n    Raises:\n        CreateRequestError: If the API returns a non-201 status code during creation.\n    \"\"\"\n    response =  self._client._post(f\"/{self.endpoint}/{str(self.id)}/uoms\", json=uom_record.model_dump(exclude_unset=True, exclude_none=True))\n    if response.get('status_code') == 201:\n        location = response.get('headers').get('location')\n        parsed_url = urlparse(location)\n        path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n        id = path_segments[-1]\n        return InventoryClient(self._client).items.get_uom(id)\n    else:\n        error_message = response.get('content')\n        raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.item.add_upc","title":"<code>add_upc(upc_record)</code>","text":"<p>Add a new UPC to the current inventory item.</p> <p>Sends a POST request to the Spire API to create a new UPC record using the provided UPC model. If the creation is successful (HTTP 201), it retrieves and returns the created UPC.</p> <p>Parameters:</p> Name Type Description Default <code>upc_record</code> <code>UPC</code> <p>The UPC Pydantic model to be created.</p> required <p>Returns:</p> Name Type Description <code>upc</code> <code>upc</code> <p>The newly created UPC as a <code>upc</code> instance.</p> <p>Raises:</p> Type Description <code>CreateRequestError</code> <p>If the API returns a non-201 status code during creation.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def add_upc(self, upc_record : UPC) -&gt; \"upc\":\n    \"\"\"\n    Add a new UPC to the current inventory item.\n\n    Sends a POST request to the Spire API to create a new UPC record using the provided\n    UPC model. If the creation is successful (HTTP 201), it retrieves\n    and returns the created UPC.\n\n    Args:\n        upc_record (UPC): The UPC Pydantic model to be created.\n\n    Returns:\n        upc (upc): The newly created UPC as a `upc` instance.\n\n    Raises:\n        CreateRequestError: If the API returns a non-201 status code during creation.\n    \"\"\"\n    response =  self._client._post(f\"/{self.endpoint}/{str(self.id)}/upcs\", json=upc_record.model_dump(exclude_unset=True, exclude_none=True))\n    if response.get('status_code') == 201:\n        location = response.get('headers').get('location')\n        parsed_url = urlparse(location)\n        path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n        id = path_segments[-1]\n        return InventoryClient(self._client).items.get_upc(id)\n    else:\n        error_message = response.get('content')\n        raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.item.delete","title":"<code>delete()</code>","text":"<p>Cancels or deletes the item.</p> <p>Sends a DELETE request to the API to remove the inventory item with the current ID.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the order was successfully deleted (HTTP 204 or 200), False otherwise.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def delete(self) -&gt; bool:\n    \"\"\"\n    Cancels or deletes the item.\n\n    Sends a DELETE request to the API to remove the inventory item with the current ID.\n\n    Returns:\n        bool: True if the order was successfully deleted (HTTP 204 or 200), False otherwise.\n    \"\"\"\n\n    return self._client._delete(f\"/{self.endpoint}/{str(self.id)}\")\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.item.get_uoms","title":"<code>get_uoms()</code>","text":"<p>Retrieve all Unit of Measure (UOM) records for the current inventory item.</p> <p>This method sends a GET request to the Spire API and returns all UOMs associated with this item's ID.</p> <p>Returns:</p> Type Description <code>List[uom]</code> <p>List[uom]: A list of <code>uom</code> instances representing the available units of measure.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def get_uoms(self) -&gt; List[\"uom\"]:\n    \"\"\"\n    Retrieve all Unit of Measure (UOM) records for the current inventory item.\n\n    This method sends a GET request to the Spire API and returns all UOMs\n    associated with this item's ID.\n\n    Returns:\n        List[uom]: A list of `uom` instances representing the available units of measure.\n    \"\"\"       \n    uoms = []\n    response = self._client._get(f\"{self.endpoint}/{self.id}/uoms\")\n    items = response.get('records')\n    for item in items:\n        uoms.append(uom.from_json(json_data=item, client = self._client, item_id = self.id))\n\n    return uoms\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.item.get_upcs","title":"<code>get_upcs()</code>","text":"<p>Retrieve all UPC records for the current inventory item.</p> <p>This method sends a GET request to the Spire API and returns all UPCs associated with this item's ID.</p> <p>Returns:</p> Type Description <code>List[upc]</code> <p>List[upc]: A list of <code>upc</code> instances representing the available units of measure.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def get_upcs(self) -&gt; List[\"upc\"]:\n    \"\"\"\n    Retrieve all UPC records for the current inventory item.\n\n    This method sends a GET request to the Spire API and returns all UPCs\n    associated with this item's ID.\n\n    Returns:\n        List[upc]: A list of `upc` instances representing the available units of measure.\n    \"\"\"     \n    upcs = []\n    response = self._client._get(f\"{self.endpoint}/{self.id}/upcs\")\n    items = response.get('records')\n    for item in items:\n        upcs.append(upc.from_json(json_data=item, client = self._client, item_id = id))\n\n    return upcs\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.item.update","title":"<code>update(inventory_item=None)</code>","text":"<p>Update the inventory item.</p> <p>If no item object is provided, updates the current instance on the server. If an item object is provided, updates the item using the given data.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_item</code> <code>item</code> <p>An optional item instance to use for the update.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>item</code> <code>item</code> <p>The updated item object reflecting the new status.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def update(self, inventory_item: \"item\" = None) -&gt; 'item':\n    \"\"\"\n    Update the inventory item.\n\n    If no item object is provided, updates the current instance on the server.\n    If an item object is provided, updates the item using the given data.\n\n    Args:\n        inventory_item (item, optional): An optional item instance to use for the update.\n\n    Returns:\n        item: The updated item object reflecting the new status.\n    \"\"\"\n    data = inventory_item.model_dump(exclude_unset=True, exclude_none=True) if inventory_item else self.model_dump(exclude_unset=True, exclude_none=True)\n    response = self._client._put(f\"/{self.endpoint}/{str(self.id)}\", json=data)\n    return item.from_json(response, self._client)    \n</code></pre>"},{"location":"api/inventory/#spyre.inventory.uom","title":"<code>uom</code>","text":"<p>               Bases: <code>APIResource[UnitOfMeasure]</code></p> Source code in <code>src/spyre/inventory.py</code> <pre><code>class uom(APIResource[UnitOfMeasure]):\n    Model = UnitOfMeasure\n    _endpoint = ''  # Will be dynamically set in __init__\n\n\n    def __init__(self, model, client, item_id=None):\n        if item_id is None:\n            raise ValueError(\"item_id must be provided\")\n        super().__init__(model, client)\n        uom_id = model.id\n        self._endpoint = f'inventory/items/{item_id}/uoms/{str(uom_id)}'\n        self._item_id = item_id\n\n    def delete(self) -&gt; bool:\n        \"\"\"\n        Cancels or deletes the uom.\n\n        Sends a DELETE request to the API to remove the uom with the current ID.\n\n        Returns:\n            bool: True if the uom was successfully deleted (HTTP 204 or 200), False otherwise.\n        \"\"\"\n\n        return self._client._delete(f\"/{self._endpoint}\")\n\n    def update(self, _uom: \"uom\" = None) -&gt; 'uom':\n        \"\"\"\n        Update the uom.\n\n        If no uom object is provided, updates the current instance on the server.\n        If an uom object is provided, updates the item using the given data.\n\n        Args:\n            _uom (uom, optional): An optional uom instance to use for the update.\n\n        Returns:\n            uom: The updated uom object reflecting the new status.\n        \"\"\"\n        data = _uom.model_dump(exclude_unset=True, exclude_none=True) if _uom else self.model_dump(exclude_unset=True, exclude_none=True)\n        response = self._client._put(f\"/{self._endpoint}\", json=data)\n        return uom.from_json(response, self._client, item_id = self._item_id)    \n</code></pre>"},{"location":"api/inventory/#spyre.inventory.uom.delete","title":"<code>delete()</code>","text":"<p>Cancels or deletes the uom.</p> <p>Sends a DELETE request to the API to remove the uom with the current ID.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the uom was successfully deleted (HTTP 204 or 200), False otherwise.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def delete(self) -&gt; bool:\n    \"\"\"\n    Cancels or deletes the uom.\n\n    Sends a DELETE request to the API to remove the uom with the current ID.\n\n    Returns:\n        bool: True if the uom was successfully deleted (HTTP 204 or 200), False otherwise.\n    \"\"\"\n\n    return self._client._delete(f\"/{self._endpoint}\")\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.uom.update","title":"<code>update(_uom=None)</code>","text":"<p>Update the uom.</p> <p>If no uom object is provided, updates the current instance on the server. If an uom object is provided, updates the item using the given data.</p> <p>Parameters:</p> Name Type Description Default <code>_uom</code> <code>uom</code> <p>An optional uom instance to use for the update.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>uom</code> <code>uom</code> <p>The updated uom object reflecting the new status.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def update(self, _uom: \"uom\" = None) -&gt; 'uom':\n    \"\"\"\n    Update the uom.\n\n    If no uom object is provided, updates the current instance on the server.\n    If an uom object is provided, updates the item using the given data.\n\n    Args:\n        _uom (uom, optional): An optional uom instance to use for the update.\n\n    Returns:\n        uom: The updated uom object reflecting the new status.\n    \"\"\"\n    data = _uom.model_dump(exclude_unset=True, exclude_none=True) if _uom else self.model_dump(exclude_unset=True, exclude_none=True)\n    response = self._client._put(f\"/{self._endpoint}\", json=data)\n    return uom.from_json(response, self._client, item_id = self._item_id)    \n</code></pre>"},{"location":"api/inventory/#spyre.inventory.upc","title":"<code>upc</code>","text":"<p>               Bases: <code>APIResource[UPC]</code></p> Source code in <code>src/spyre/inventory.py</code> <pre><code>class upc(APIResource[UPC]):\n    _endpoint = ''         \n    Model = UPC\n\n    def __init__(self, model, client, item_id=None):\n\n        super().__init__(model, client)\n        upc_id = model.id\n        if item_id is None:\n            self._endpoint = f'inventory/upcs/{str(upc_id)}'\n        else:\n            self._endpoint = f'inventory/items/{item_id}/upcs/{str(upc_id)}'\n        self._item_id = item_id\n\n    def delete(self) -&gt; bool:\n        \"\"\"\n        Cancels or deletes the upc.\n\n        Sends a DELETE request to the API to remove the upc with the current ID.\n\n        Returns:\n            bool: True if the upc was successfully deleted (HTTP 204 or 200), False otherwise.\n        \"\"\"\n\n        return self._client._delete(f\"/{self._endpoint}\")\n\n    def update(self, _upc: \"upc\" = None) -&gt; 'upc':\n        \"\"\"\n        Update the upc.\n\n        If no upc object is provided, updates the current instance on the server.\n        If an upc object is provided, updates the item using the given data.\n\n        Args:\n            _upc (upc, optional): An optional upc instance to use for the update.\n\n        Returns:\n            upc: The updated upc object reflecting the new status.\n        \"\"\"\n        data = _upc.model_dump(exclude_unset=True, exclude_none=True) if _upc else self.model_dump(exclude_unset=True, exclude_none=True)\n        response = self._client._put(f\"/{self._endpoint}\", json=data)\n        return upc.from_json(response, self._client, item_id = self._item_id)    \n</code></pre>"},{"location":"api/inventory/#spyre.inventory.upc.delete","title":"<code>delete()</code>","text":"<p>Cancels or deletes the upc.</p> <p>Sends a DELETE request to the API to remove the upc with the current ID.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the upc was successfully deleted (HTTP 204 or 200), False otherwise.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def delete(self) -&gt; bool:\n    \"\"\"\n    Cancels or deletes the upc.\n\n    Sends a DELETE request to the API to remove the upc with the current ID.\n\n    Returns:\n        bool: True if the upc was successfully deleted (HTTP 204 or 200), False otherwise.\n    \"\"\"\n\n    return self._client._delete(f\"/{self._endpoint}\")\n</code></pre>"},{"location":"api/inventory/#spyre.inventory.upc.update","title":"<code>update(_upc=None)</code>","text":"<p>Update the upc.</p> <p>If no upc object is provided, updates the current instance on the server. If an upc object is provided, updates the item using the given data.</p> <p>Parameters:</p> Name Type Description Default <code>_upc</code> <code>upc</code> <p>An optional upc instance to use for the update.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>upc</code> <code>upc</code> <p>The updated upc object reflecting the new status.</p> Source code in <code>src/spyre/inventory.py</code> <pre><code>def update(self, _upc: \"upc\" = None) -&gt; 'upc':\n    \"\"\"\n    Update the upc.\n\n    If no upc object is provided, updates the current instance on the server.\n    If an upc object is provided, updates the item using the given data.\n\n    Args:\n        _upc (upc, optional): An optional upc instance to use for the update.\n\n    Returns:\n        upc: The updated upc object reflecting the new status.\n    \"\"\"\n    data = _upc.model_dump(exclude_unset=True, exclude_none=True) if _upc else self.model_dump(exclude_unset=True, exclude_none=True)\n    response = self._client._put(f\"/{self._endpoint}\", json=data)\n    return upc.from_json(response, self._client, item_id = self._item_id)    \n</code></pre>"},{"location":"api/purchasing/","title":"Purchasing","text":""},{"location":"api/purchasing/#spyre.purchasing.PurchasingClient","title":"<code>PurchasingClient</code>","text":"Source code in <code>src/spyre/purchasing.py</code> <pre><code>class PurchasingClient:\n\n    def __init__(self, client: SpireClient):\n        self.client = client\n        self.endpoint = \"purchasing/orders\"\n\n    def get_purchase_order(self, id: int = None, PO_number: str = None) -&gt; 'purchaseOrder':\n        \"\"\"\n        Retrieve a purchase order by its ID or PO number.\n\n        Args:\n            id (int, optional): The ID of the purchase order to retrieve.\n            PO_number (str, optional): The purchase order number of the purchase order to retrieve.\n\n        Returns:\n            purchaseOrder: A `purchaseOrder` wrapper instance containing the retrieved data.\n\n        Raises:\n            ValueError: If neither id nor PO_number is provided, or if no matching order is found.\n        \"\"\"\n        if id is not None:\n            response = self.client._get(f\"/{self.endpoint}/{str(id)}\")\n            return purchaseOrder.from_json(response, self.client)\n        elif PO_number is not None:\n            orders = self.query_purchase_order(query=PO_number)\n            for order in orders:\n                if getattr(order, \"number\", None) == PO_number:\n                    return self.get_purchase_order(order.id)\n            raise ValueError(f\"No purchase order found for purchase order {PO_number}\")\n        else:\n            raise ValueError(\"Either 'id' or 'PO_number' must be provided.\")\n\n    def create_purchase_order(self, purchase_order: 'PurchaseOrder') -&gt; 'purchaseOrder':\n        \"\"\"\n        Create a new purchase order.\n\n        Sends a POST request to the purchase order endpoint.\n\n        Args:\n            purchase_order (dict): A PurchaseOrder instance containing the purchase order details.\n\n        Returns:\n            purchaseOrder: The create PurchaseOrder instance.\n\n        Raises:\n            CreateRequestError: If the creation fails or response is invalid.\n        \"\"\"\n        if hasattr(purchase_order, \"model_dump_json\"):  # Pydantic v2\n            payload = json.loads(\n                purchase_order.model_dump_json(\n                    exclude_unset=True,\n                    exclude_none=True,\n                    by_alias=True,   # keep camelCase if you use aliases\n                )\n            )\n        else:  # Pydantic v1 fallback\n            payload = json.loads(\n                purchase_order.json(\n                    exclude_unset=True,\n                    exclude_none=True,\n                    by_alias=True,\n                )\n            )\n        response = self.client._post(f\"/{self.endpoint}\", json=payload)\n        if response.get('status_code') == 201:\n            location = response.get('headers').get('location')\n            parsed_url = urlparse(location)\n            path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n            id = path_segments[-1]\n            return self.get_purchase_order(id)\n        else:\n            error_message = response.get('content')\n            raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n\n    def update_purchase_order(self, id: int, purchase_order: 'purchaseOrder') -&gt; 'purchaseOrder':\n        \"\"\"\n        Update an existing purchase order by ID.\n\n        Sends a PUT request to the purchase order endpoint with the provided sales order data\n        to update the existing record. Returns a wrapped `purchaseOrder` object containing\n        the updated information.\n\n        Args:\n            id (int): The ID of the purchase order to update.\n            purchase_order (PurchaseOrder): A PurchaseOrder instance with the purchase order details.\n\n        Returns:\n            purchaseOrder: An instance of the purchaseOrder wrapper class initialized with the \n                           updated data and client session.\n        \"\"\"\n        if purchase_order.status == \"I\":\n            raise ValueError(f\"Cannot update an issued purchase order for {purchase_order.number}\")\n        else:\n            response = self.client._put(f\"/{self.endpoint}/{str(id)}\", json=purchase_order.model_dump(exclude_none=True, exclude_unset=True))\n        return purchaseOrder.from_json(response, self.client)\n\n    def delete_purchase_order(self, id: int) -&gt; bool:\n        \"\"\"\n        Delete a purchase order by its ID.\n\n        Sends a DELETE request to the purchase order endpoint to remove the specified\n        purchase order from the system.\n\n        Args:\n            id (int): The ID of the purchase order to delete.\n\n        Returns:\n            bool: True if the sales order was successfully deleted, False otherwise.\n        \"\"\"\n        order = self.get_purchase_order(id)\n        if order.model.status in (\"I\", \"R\"):\n            raise ValueError(f\"Cannot delete an issued or received purchase order for {order.number}\")\n        else:\n            return self.client._delete(f\"/{self.endpoint}/{str(id)}\")\n\n    def query_purchase_order(\n            self,\n            *,\n            query: Optional[str] = None,\n            sort: Optional[Dict[str,str]] = None,\n            filter: Optional[Dict[str, Any]] = None,\n            all: bool = False,\n            limit: int = 1000,\n            start: int = 0,\n            **extra_params\n    ) -&gt; List[\"purchaseOrder\"]:\n        \"\"\"\n        Query purchase orders with optional full-text search, filtering, multi-field sorting, and pagination.\n\n        Args:\n            query (str, optional): Full-text search string.\n            sort (dict, optional): Dictionary of sorting rules (e.g., {\"date\": \"desc\", \"number\": \"asc\"}).\n            filter (dict, optional): Dictionary of filters to apply (will be JSON-encoded and URL-safe).\n            all (bool, optional): If True, retrieves all pages of results.\n            limit (int, optional): Number of results per page (max 1000).\n            start (int, optional): Starting offset for pagination.\n            **extra_params (Any): Any additional parameters to include in the query.\n\n        Returns:\n            List[purchaseOrder]: List of wrapped purchase order resources.\n        \"\"\"\n        return self.client._query(\n            endpoint=self.endpoint,\n            resource_cls=purchaseOrder,\n            query=query,\n            sort=sort,\n            filter=filter,\n            all=all,\n            limit=limit,\n            start=start,\n            **extra_params\n        )\n\n    def issue_purchase_order(self, id:int) -&gt; 'purchaseOrder':\n        \"\"\"\n        Issue a purchase order by its ID.\n\n        Sends a request to Spire to change the purchase order's status to\n        \u201cIssued\u201d. Issuing an order typically means it has been confirmed\n        and is ready to be sent to the vendor.\n\n        Args:\n            id (int): The ID of the purchaseOrder to issue.\n\n        Returns:\n            purchaseOrder: The updated purchase order object with the status set to \"I\" (Issued).\n\n        Raises:\n            CreateRequestError: If the request fails or the API returns an error status.\n        \"\"\"\n        response = self.client._post(f\"/{self.endpoint}/{str(id)}/issue\")\n        if response.get(\"status_code\") != 200:\n            raise CreateRequestError(f\"Failed to issue purchase order: {id}: {response.text}\")\n        return purchaseOrder.from_json(response, self.client)\n\n    def receive_purchase_order(self, id: int, receiveAll: bool = None) -&gt; 'purchaseOrder':\n        \"\"\"\n        Receive a purchase order by its ID.\n\n        This updates the order in Spire to reflect that items have been received. \n        Typically, this should only be called on purchase orders with status \"Issued\".\n\n        Args:\n            id (int): The ID of the purchaseOrder to receive.\n            receiveAll (bool, optional): An optional boolean to recieve all quantites on the purchase order.\n\n        Returns:\n            purchaseOrder: The updated purchase order object with the status set to \"R\" (Received).\n\n        Raises: CreateRequestError: If the request fails or the API returns an error status.\n        \"\"\"\n        if receiveAll:\n            order = self.get_purchase_order(id)\n            for item in order.model.items:\n                item.receiveQty = item.orderQty\n            order.update()\n        response = self.client._post(f\"/{self.endpoint}/{str(id)}/receive\")\n        if response.get(\"status_code\") != 200:\n            raise CreateRequestError(f\"Failed to receive purchase order: {id}: {response.text}\")\n        return purchaseOrder.from_json(response, self.client)\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.PurchasingClient.create_purchase_order","title":"<code>create_purchase_order(purchase_order)</code>","text":"<p>Create a new purchase order.</p> <p>Sends a POST request to the purchase order endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>purchase_order</code> <code>dict</code> <p>A PurchaseOrder instance containing the purchase order details.</p> required <p>Returns:</p> Name Type Description <code>purchaseOrder</code> <code>purchaseOrder</code> <p>The create PurchaseOrder instance.</p> <p>Raises:</p> Type Description <code>CreateRequestError</code> <p>If the creation fails or response is invalid.</p> Source code in <code>src/spyre/purchasing.py</code> <pre><code>def create_purchase_order(self, purchase_order: 'PurchaseOrder') -&gt; 'purchaseOrder':\n    \"\"\"\n    Create a new purchase order.\n\n    Sends a POST request to the purchase order endpoint.\n\n    Args:\n        purchase_order (dict): A PurchaseOrder instance containing the purchase order details.\n\n    Returns:\n        purchaseOrder: The create PurchaseOrder instance.\n\n    Raises:\n        CreateRequestError: If the creation fails or response is invalid.\n    \"\"\"\n    if hasattr(purchase_order, \"model_dump_json\"):  # Pydantic v2\n        payload = json.loads(\n            purchase_order.model_dump_json(\n                exclude_unset=True,\n                exclude_none=True,\n                by_alias=True,   # keep camelCase if you use aliases\n            )\n        )\n    else:  # Pydantic v1 fallback\n        payload = json.loads(\n            purchase_order.json(\n                exclude_unset=True,\n                exclude_none=True,\n                by_alias=True,\n            )\n        )\n    response = self.client._post(f\"/{self.endpoint}\", json=payload)\n    if response.get('status_code') == 201:\n        location = response.get('headers').get('location')\n        parsed_url = urlparse(location)\n        path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n        id = path_segments[-1]\n        return self.get_purchase_order(id)\n    else:\n        error_message = response.get('content')\n        raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.PurchasingClient.delete_purchase_order","title":"<code>delete_purchase_order(id)</code>","text":"<p>Delete a purchase order by its ID.</p> <p>Sends a DELETE request to the purchase order endpoint to remove the specified purchase order from the system.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the purchase order to delete.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the sales order was successfully deleted, False otherwise.</p> Source code in <code>src/spyre/purchasing.py</code> <pre><code>def delete_purchase_order(self, id: int) -&gt; bool:\n    \"\"\"\n    Delete a purchase order by its ID.\n\n    Sends a DELETE request to the purchase order endpoint to remove the specified\n    purchase order from the system.\n\n    Args:\n        id (int): The ID of the purchase order to delete.\n\n    Returns:\n        bool: True if the sales order was successfully deleted, False otherwise.\n    \"\"\"\n    order = self.get_purchase_order(id)\n    if order.model.status in (\"I\", \"R\"):\n        raise ValueError(f\"Cannot delete an issued or received purchase order for {order.number}\")\n    else:\n        return self.client._delete(f\"/{self.endpoint}/{str(id)}\")\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.PurchasingClient.get_purchase_order","title":"<code>get_purchase_order(id=None, PO_number=None)</code>","text":"<p>Retrieve a purchase order by its ID or PO number.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the purchase order to retrieve.</p> <code>None</code> <code>PO_number</code> <code>str</code> <p>The purchase order number of the purchase order to retrieve.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>purchaseOrder</code> <code>purchaseOrder</code> <p>A <code>purchaseOrder</code> wrapper instance containing the retrieved data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither id nor PO_number is provided, or if no matching order is found.</p> Source code in <code>src/spyre/purchasing.py</code> <pre><code>def get_purchase_order(self, id: int = None, PO_number: str = None) -&gt; 'purchaseOrder':\n    \"\"\"\n    Retrieve a purchase order by its ID or PO number.\n\n    Args:\n        id (int, optional): The ID of the purchase order to retrieve.\n        PO_number (str, optional): The purchase order number of the purchase order to retrieve.\n\n    Returns:\n        purchaseOrder: A `purchaseOrder` wrapper instance containing the retrieved data.\n\n    Raises:\n        ValueError: If neither id nor PO_number is provided, or if no matching order is found.\n    \"\"\"\n    if id is not None:\n        response = self.client._get(f\"/{self.endpoint}/{str(id)}\")\n        return purchaseOrder.from_json(response, self.client)\n    elif PO_number is not None:\n        orders = self.query_purchase_order(query=PO_number)\n        for order in orders:\n            if getattr(order, \"number\", None) == PO_number:\n                return self.get_purchase_order(order.id)\n        raise ValueError(f\"No purchase order found for purchase order {PO_number}\")\n    else:\n        raise ValueError(\"Either 'id' or 'PO_number' must be provided.\")\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.PurchasingClient.issue_purchase_order","title":"<code>issue_purchase_order(id)</code>","text":"<p>Issue a purchase order by its ID.</p> <p>Sends a request to Spire to change the purchase order's status to \u201cIssued\u201d. Issuing an order typically means it has been confirmed and is ready to be sent to the vendor.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the purchaseOrder to issue.</p> required <p>Returns:</p> Name Type Description <code>purchaseOrder</code> <code>purchaseOrder</code> <p>The updated purchase order object with the status set to \"I\" (Issued).</p> <p>Raises:</p> Type Description <code>CreateRequestError</code> <p>If the request fails or the API returns an error status.</p> Source code in <code>src/spyre/purchasing.py</code> <pre><code>def issue_purchase_order(self, id:int) -&gt; 'purchaseOrder':\n    \"\"\"\n    Issue a purchase order by its ID.\n\n    Sends a request to Spire to change the purchase order's status to\n    \u201cIssued\u201d. Issuing an order typically means it has been confirmed\n    and is ready to be sent to the vendor.\n\n    Args:\n        id (int): The ID of the purchaseOrder to issue.\n\n    Returns:\n        purchaseOrder: The updated purchase order object with the status set to \"I\" (Issued).\n\n    Raises:\n        CreateRequestError: If the request fails or the API returns an error status.\n    \"\"\"\n    response = self.client._post(f\"/{self.endpoint}/{str(id)}/issue\")\n    if response.get(\"status_code\") != 200:\n        raise CreateRequestError(f\"Failed to issue purchase order: {id}: {response.text}\")\n    return purchaseOrder.from_json(response, self.client)\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.PurchasingClient.query_purchase_order","title":"<code>query_purchase_order(*, query=None, sort=None, filter=None, all=False, limit=1000, start=0, **extra_params)</code>","text":"<p>Query purchase orders with optional full-text search, filtering, multi-field sorting, and pagination.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Full-text search string.</p> <code>None</code> <code>sort</code> <code>dict</code> <p>Dictionary of sorting rules (e.g., {\"date\": \"desc\", \"number\": \"asc\"}).</p> <code>None</code> <code>filter</code> <code>dict</code> <p>Dictionary of filters to apply (will be JSON-encoded and URL-safe).</p> <code>None</code> <code>all</code> <code>bool</code> <p>If True, retrieves all pages of results.</p> <code>False</code> <code>limit</code> <code>int</code> <p>Number of results per page (max 1000).</p> <code>1000</code> <code>start</code> <code>int</code> <p>Starting offset for pagination.</p> <code>0</code> <code>**extra_params</code> <code>Any</code> <p>Any additional parameters to include in the query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[purchaseOrder]</code> <p>List[purchaseOrder]: List of wrapped purchase order resources.</p> Source code in <code>src/spyre/purchasing.py</code> <pre><code>def query_purchase_order(\n        self,\n        *,\n        query: Optional[str] = None,\n        sort: Optional[Dict[str,str]] = None,\n        filter: Optional[Dict[str, Any]] = None,\n        all: bool = False,\n        limit: int = 1000,\n        start: int = 0,\n        **extra_params\n) -&gt; List[\"purchaseOrder\"]:\n    \"\"\"\n    Query purchase orders with optional full-text search, filtering, multi-field sorting, and pagination.\n\n    Args:\n        query (str, optional): Full-text search string.\n        sort (dict, optional): Dictionary of sorting rules (e.g., {\"date\": \"desc\", \"number\": \"asc\"}).\n        filter (dict, optional): Dictionary of filters to apply (will be JSON-encoded and URL-safe).\n        all (bool, optional): If True, retrieves all pages of results.\n        limit (int, optional): Number of results per page (max 1000).\n        start (int, optional): Starting offset for pagination.\n        **extra_params (Any): Any additional parameters to include in the query.\n\n    Returns:\n        List[purchaseOrder]: List of wrapped purchase order resources.\n    \"\"\"\n    return self.client._query(\n        endpoint=self.endpoint,\n        resource_cls=purchaseOrder,\n        query=query,\n        sort=sort,\n        filter=filter,\n        all=all,\n        limit=limit,\n        start=start,\n        **extra_params\n    )\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.PurchasingClient.receive_purchase_order","title":"<code>receive_purchase_order(id, receiveAll=None)</code>","text":"<p>Receive a purchase order by its ID.</p> <p>This updates the order in Spire to reflect that items have been received.  Typically, this should only be called on purchase orders with status \"Issued\".</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the purchaseOrder to receive.</p> required <code>receiveAll</code> <code>bool</code> <p>An optional boolean to recieve all quantites on the purchase order.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>purchaseOrder</code> <code>purchaseOrder</code> <p>The updated purchase order object with the status set to \"R\" (Received).</p> <p>Raises: CreateRequestError: If the request fails or the API returns an error status.</p> Source code in <code>src/spyre/purchasing.py</code> <pre><code>def receive_purchase_order(self, id: int, receiveAll: bool = None) -&gt; 'purchaseOrder':\n    \"\"\"\n    Receive a purchase order by its ID.\n\n    This updates the order in Spire to reflect that items have been received. \n    Typically, this should only be called on purchase orders with status \"Issued\".\n\n    Args:\n        id (int): The ID of the purchaseOrder to receive.\n        receiveAll (bool, optional): An optional boolean to recieve all quantites on the purchase order.\n\n    Returns:\n        purchaseOrder: The updated purchase order object with the status set to \"R\" (Received).\n\n    Raises: CreateRequestError: If the request fails or the API returns an error status.\n    \"\"\"\n    if receiveAll:\n        order = self.get_purchase_order(id)\n        for item in order.model.items:\n            item.receiveQty = item.orderQty\n        order.update()\n    response = self.client._post(f\"/{self.endpoint}/{str(id)}/receive\")\n    if response.get(\"status_code\") != 200:\n        raise CreateRequestError(f\"Failed to receive purchase order: {id}: {response.text}\")\n    return purchaseOrder.from_json(response, self.client)\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.PurchasingClient.update_purchase_order","title":"<code>update_purchase_order(id, purchase_order)</code>","text":"<p>Update an existing purchase order by ID.</p> <p>Sends a PUT request to the purchase order endpoint with the provided sales order data to update the existing record. Returns a wrapped <code>purchaseOrder</code> object containing the updated information.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the purchase order to update.</p> required <code>purchase_order</code> <code>PurchaseOrder</code> <p>A PurchaseOrder instance with the purchase order details.</p> required <p>Returns:</p> Name Type Description <code>purchaseOrder</code> <code>purchaseOrder</code> <p>An instance of the purchaseOrder wrapper class initialized with the             updated data and client session.</p> Source code in <code>src/spyre/purchasing.py</code> <pre><code>def update_purchase_order(self, id: int, purchase_order: 'purchaseOrder') -&gt; 'purchaseOrder':\n    \"\"\"\n    Update an existing purchase order by ID.\n\n    Sends a PUT request to the purchase order endpoint with the provided sales order data\n    to update the existing record. Returns a wrapped `purchaseOrder` object containing\n    the updated information.\n\n    Args:\n        id (int): The ID of the purchase order to update.\n        purchase_order (PurchaseOrder): A PurchaseOrder instance with the purchase order details.\n\n    Returns:\n        purchaseOrder: An instance of the purchaseOrder wrapper class initialized with the \n                       updated data and client session.\n    \"\"\"\n    if purchase_order.status == \"I\":\n        raise ValueError(f\"Cannot update an issued purchase order for {purchase_order.number}\")\n    else:\n        response = self.client._put(f\"/{self.endpoint}/{str(id)}\", json=purchase_order.model_dump(exclude_none=True, exclude_unset=True))\n    return purchaseOrder.from_json(response, self.client)\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.PurchasingHistoryClient","title":"<code>PurchasingHistoryClient</code>","text":"Source code in <code>src/spyre/purchasing.py</code> <pre><code>class PurchasingHistoryClient:\n\n    def __init__(self, client: SpireClient):\n        self.client = client\n        self.endpoint = \"purchasing/history\"\n\n    def get_purchase_history_order(self, id: int = None, PO_number: str = None) -&gt; 'purchaseOrder':\n        \"\"\"\n        Retrieve an archived purchase order by its ID or PO number.\n\n        Args:\n            id (int, optional): The ID of the purchase order to retrieve.\n            PO_number (str, optional): The purchase order number of the purchase order to retrieve.\n\n        Returns:\n            purchaseOrder: A `purchaseOrder` wrapper instance containing the retrieved data.\n\n        Raises:\n            ValueError: If neither id nor PO_number is provieded, or if no matching purchase order is found.\n        \"\"\"\n        if id is not None:\n            response = self.client._get(f\"/{self.endpoint}/{str(id)}\")\n            return purchaseOrder.from_json(response, self.client)\n        elif PO_number is not None:\n            orders = self.query_purchase_history_order(query=PO_number)\n            for order in orders:\n                if getattr(order, \"number\", None) == PO_number:\n                    return self.get_purchase_history_order(order.id)\n            raise ValueError(f\"No purchase order found for purchase order {PO_number}\")\n        else:\n            raise ValueError(\"Either 'id' or 'PO_number' must be provided.\")\n\n    def query_purchase_history_order(\n            self,\n            *,\n            query: Optional[str] = None,\n            sort: Optional[Dict[str,str]] = None,\n            filter: Optional[Dict[str, Any]] = None,\n            all: bool = False,\n            limit: int = 1000,\n            start: int = 0,\n            **extra_params\n    ) -&gt; List[\"purchaseOrder\"]:\n        \"\"\"\n        Query archived purchase orders with optional full-text search, filtering, multi-field sorting, and pagination.\n\n        Args:\n            query (str, optional): Full-text search string.\n            sort (dict, optional): Dictionary of sorting rules (e.g., {\"date\": \"desc\", \"number\": \"asc\"}).\n            filter (dict, optional): Dictionary of filters to apply (will be JSON-encoded and URL-safe).\n            all (bool, optional): If True, retrieves all pages of results.\n            limit (int, optional): Number of results per page (max 1000).\n            start (int, optional): Starting offset for pagination.\n            **extra_params (Any): Any additional parameters to include in the query.\n\n        Returns:\n            List[purchaseOrder]: List of wrapped purchase order resources.\n        \"\"\"\n        return self.client._query(\n            endpoint=self.endpoint,\n            resource_cls=purchaseOrder,\n            query=query,\n            sort=sort,\n            filter=filter,\n            all=all,\n            limit=limit,\n            start=start,\n            **extra_params\n        )\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.PurchasingHistoryClient.get_purchase_history_order","title":"<code>get_purchase_history_order(id=None, PO_number=None)</code>","text":"<p>Retrieve an archived purchase order by its ID or PO number.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the purchase order to retrieve.</p> <code>None</code> <code>PO_number</code> <code>str</code> <p>The purchase order number of the purchase order to retrieve.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>purchaseOrder</code> <code>purchaseOrder</code> <p>A <code>purchaseOrder</code> wrapper instance containing the retrieved data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither id nor PO_number is provieded, or if no matching purchase order is found.</p> Source code in <code>src/spyre/purchasing.py</code> <pre><code>def get_purchase_history_order(self, id: int = None, PO_number: str = None) -&gt; 'purchaseOrder':\n    \"\"\"\n    Retrieve an archived purchase order by its ID or PO number.\n\n    Args:\n        id (int, optional): The ID of the purchase order to retrieve.\n        PO_number (str, optional): The purchase order number of the purchase order to retrieve.\n\n    Returns:\n        purchaseOrder: A `purchaseOrder` wrapper instance containing the retrieved data.\n\n    Raises:\n        ValueError: If neither id nor PO_number is provieded, or if no matching purchase order is found.\n    \"\"\"\n    if id is not None:\n        response = self.client._get(f\"/{self.endpoint}/{str(id)}\")\n        return purchaseOrder.from_json(response, self.client)\n    elif PO_number is not None:\n        orders = self.query_purchase_history_order(query=PO_number)\n        for order in orders:\n            if getattr(order, \"number\", None) == PO_number:\n                return self.get_purchase_history_order(order.id)\n        raise ValueError(f\"No purchase order found for purchase order {PO_number}\")\n    else:\n        raise ValueError(\"Either 'id' or 'PO_number' must be provided.\")\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.PurchasingHistoryClient.query_purchase_history_order","title":"<code>query_purchase_history_order(*, query=None, sort=None, filter=None, all=False, limit=1000, start=0, **extra_params)</code>","text":"<p>Query archived purchase orders with optional full-text search, filtering, multi-field sorting, and pagination.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Full-text search string.</p> <code>None</code> <code>sort</code> <code>dict</code> <p>Dictionary of sorting rules (e.g., {\"date\": \"desc\", \"number\": \"asc\"}).</p> <code>None</code> <code>filter</code> <code>dict</code> <p>Dictionary of filters to apply (will be JSON-encoded and URL-safe).</p> <code>None</code> <code>all</code> <code>bool</code> <p>If True, retrieves all pages of results.</p> <code>False</code> <code>limit</code> <code>int</code> <p>Number of results per page (max 1000).</p> <code>1000</code> <code>start</code> <code>int</code> <p>Starting offset for pagination.</p> <code>0</code> <code>**extra_params</code> <code>Any</code> <p>Any additional parameters to include in the query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[purchaseOrder]</code> <p>List[purchaseOrder]: List of wrapped purchase order resources.</p> Source code in <code>src/spyre/purchasing.py</code> <pre><code>def query_purchase_history_order(\n        self,\n        *,\n        query: Optional[str] = None,\n        sort: Optional[Dict[str,str]] = None,\n        filter: Optional[Dict[str, Any]] = None,\n        all: bool = False,\n        limit: int = 1000,\n        start: int = 0,\n        **extra_params\n) -&gt; List[\"purchaseOrder\"]:\n    \"\"\"\n    Query archived purchase orders with optional full-text search, filtering, multi-field sorting, and pagination.\n\n    Args:\n        query (str, optional): Full-text search string.\n        sort (dict, optional): Dictionary of sorting rules (e.g., {\"date\": \"desc\", \"number\": \"asc\"}).\n        filter (dict, optional): Dictionary of filters to apply (will be JSON-encoded and URL-safe).\n        all (bool, optional): If True, retrieves all pages of results.\n        limit (int, optional): Number of results per page (max 1000).\n        start (int, optional): Starting offset for pagination.\n        **extra_params (Any): Any additional parameters to include in the query.\n\n    Returns:\n        List[purchaseOrder]: List of wrapped purchase order resources.\n    \"\"\"\n    return self.client._query(\n        endpoint=self.endpoint,\n        resource_cls=purchaseOrder,\n        query=query,\n        sort=sort,\n        filter=filter,\n        all=all,\n        limit=limit,\n        start=start,\n        **extra_params\n    )\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.purchaseOrder","title":"<code>purchaseOrder</code>","text":"<p>               Bases: <code>APIResource[PurchaseOrder]</code></p> Source code in <code>src/spyre/purchasing.py</code> <pre><code>class purchaseOrder(APIResource[PurchaseOrder]):\n    endpoint = \"purchasing/orders\"\n    Model = PurchaseOrder\n\n    def issue(self) -&gt; 'purchaseOrder':\n        \"\"\"\n        Issue this purchase order.\n\n        Sends a POST request to Spire to change the purchase order's status to\n        \u201cI\u201d (Issued). Issuing an order typically means it has been confirmed\n        and is ready to be sent to the vendor.\n\n        Returns:\n            purchaseOrder: The updated purchase order object with the status set to \"I\" (Issued).\n\n        Raise:\n            CreateRequestError: If the request fails or the API returns an error status.\n        \"\"\"\n        response = self._client._post(f\"/{self.endpoint}/{str(self.id)}/issue\")\n        if response.get(\"status_code\") != 200:\n            raise CreateRequestError(f\"Failed to issue purchase order: {self.id}: {response.text}\")\n        return purchaseOrder.from_json(response, self._client)\n\n    def delete(self) -&gt; bool:\n        \"\"\"\n        Cancels and deletes this purchase order.\n\n        Sends a DELETE request to the API to remove the purchase order with the current ID.\n\n        Returns:\n            bool: True if the order was successfully deleted (HTTP 204 or 200), False otherwise.\n        \"\"\"\n        return self._client._delete(f\"/{self.endpoint}/{str(self.id)}\")\n\n    def update(self, order: \"purchaseOrder\" = None) -&gt; 'purchaseOrder':\n        \"\"\"\n        Update this sales order.\n\n        If no purchase order object is provided, updates the current instance on the server.\n        If a purchase order object is provided, updates the purchase order using the given data.\n\n        Args:\n            order (purchaseOrder, optional): An optional purchaseOrder instance to use for the update.\n\n        Returns: \n            purchaseOrder: The updated purchaseOrder object reflecting the new status.\n        \"\"\"\n        data = order.model_dump(exclude_unset=True, exclude_none=True) if order else self.model_dump(exclude_unset=True, exclude_none=True)\n        response = self._client._put(f\"/{self.endpoint}/{str(self.id)}\", json=data)\n        return purchaseOrder.from_json(response, self._client)\n\n    def receive(self, receiveAll: bool = None) -&gt; 'purchaseOrder':\n        \"\"\"\n        Receive this purchase order.\n\n        Sends a POST request to Spire to change the purchase order's status to\n        \"R\" (Received). Receiving an order typically means the received quantites have been\n        entered and the order is ready to be invoiced.\n\n        Args:\n            receiveAll (bool, optional): An optional boolean to recieve all quantites on the purchase order.\n\n        Returns:\n            purchaseOrder: The updated purchase order object with the status set to \"R\" (Received).\n\n        Raise: \n            CreateRequestError: If the request fails or the API returns an error status.\n        \"\"\"\n        if receiveAll:\n            for item in self.model.items:\n                item.receiveQty = item.orderQty\n            self.update()\n        response = self._client._post(f\"/{self.endpoint}/{str(self.id)}/receive\")\n        if response.get('status_code') != 200:\n            raise CreateRequestError(f\"Failed to receive purchase order: {self.id}. (Check Order Quantites): {response.text}\")\n        return purchaseOrder.from_json(response, self._client)\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.purchaseOrder.delete","title":"<code>delete()</code>","text":"<p>Cancels and deletes this purchase order.</p> <p>Sends a DELETE request to the API to remove the purchase order with the current ID.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the order was successfully deleted (HTTP 204 or 200), False otherwise.</p> Source code in <code>src/spyre/purchasing.py</code> <pre><code>def delete(self) -&gt; bool:\n    \"\"\"\n    Cancels and deletes this purchase order.\n\n    Sends a DELETE request to the API to remove the purchase order with the current ID.\n\n    Returns:\n        bool: True if the order was successfully deleted (HTTP 204 or 200), False otherwise.\n    \"\"\"\n    return self._client._delete(f\"/{self.endpoint}/{str(self.id)}\")\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.purchaseOrder.issue","title":"<code>issue()</code>","text":"<p>Issue this purchase order.</p> <p>Sends a POST request to Spire to change the purchase order's status to \u201cI\u201d (Issued). Issuing an order typically means it has been confirmed and is ready to be sent to the vendor.</p> <p>Returns:</p> Name Type Description <code>purchaseOrder</code> <code>purchaseOrder</code> <p>The updated purchase order object with the status set to \"I\" (Issued).</p> Raise <p>CreateRequestError: If the request fails or the API returns an error status.</p> Source code in <code>src/spyre/purchasing.py</code> <pre><code>def issue(self) -&gt; 'purchaseOrder':\n    \"\"\"\n    Issue this purchase order.\n\n    Sends a POST request to Spire to change the purchase order's status to\n    \u201cI\u201d (Issued). Issuing an order typically means it has been confirmed\n    and is ready to be sent to the vendor.\n\n    Returns:\n        purchaseOrder: The updated purchase order object with the status set to \"I\" (Issued).\n\n    Raise:\n        CreateRequestError: If the request fails or the API returns an error status.\n    \"\"\"\n    response = self._client._post(f\"/{self.endpoint}/{str(self.id)}/issue\")\n    if response.get(\"status_code\") != 200:\n        raise CreateRequestError(f\"Failed to issue purchase order: {self.id}: {response.text}\")\n    return purchaseOrder.from_json(response, self._client)\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.purchaseOrder.receive","title":"<code>receive(receiveAll=None)</code>","text":"<p>Receive this purchase order.</p> <p>Sends a POST request to Spire to change the purchase order's status to \"R\" (Received). Receiving an order typically means the received quantites have been entered and the order is ready to be invoiced.</p> <p>Parameters:</p> Name Type Description Default <code>receiveAll</code> <code>bool</code> <p>An optional boolean to recieve all quantites on the purchase order.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>purchaseOrder</code> <code>purchaseOrder</code> <p>The updated purchase order object with the status set to \"R\" (Received).</p> Raise <p>CreateRequestError: If the request fails or the API returns an error status.</p> Source code in <code>src/spyre/purchasing.py</code> <pre><code>def receive(self, receiveAll: bool = None) -&gt; 'purchaseOrder':\n    \"\"\"\n    Receive this purchase order.\n\n    Sends a POST request to Spire to change the purchase order's status to\n    \"R\" (Received). Receiving an order typically means the received quantites have been\n    entered and the order is ready to be invoiced.\n\n    Args:\n        receiveAll (bool, optional): An optional boolean to recieve all quantites on the purchase order.\n\n    Returns:\n        purchaseOrder: The updated purchase order object with the status set to \"R\" (Received).\n\n    Raise: \n        CreateRequestError: If the request fails or the API returns an error status.\n    \"\"\"\n    if receiveAll:\n        for item in self.model.items:\n            item.receiveQty = item.orderQty\n        self.update()\n    response = self._client._post(f\"/{self.endpoint}/{str(self.id)}/receive\")\n    if response.get('status_code') != 200:\n        raise CreateRequestError(f\"Failed to receive purchase order: {self.id}. (Check Order Quantites): {response.text}\")\n    return purchaseOrder.from_json(response, self._client)\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.purchaseOrder.update","title":"<code>update(order=None)</code>","text":"<p>Update this sales order.</p> <p>If no purchase order object is provided, updates the current instance on the server. If a purchase order object is provided, updates the purchase order using the given data.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>purchaseOrder</code> <p>An optional purchaseOrder instance to use for the update.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>purchaseOrder</code> <code>purchaseOrder</code> <p>The updated purchaseOrder object reflecting the new status.</p> Source code in <code>src/spyre/purchasing.py</code> <pre><code>def update(self, order: \"purchaseOrder\" = None) -&gt; 'purchaseOrder':\n    \"\"\"\n    Update this sales order.\n\n    If no purchase order object is provided, updates the current instance on the server.\n    If a purchase order object is provided, updates the purchase order using the given data.\n\n    Args:\n        order (purchaseOrder, optional): An optional purchaseOrder instance to use for the update.\n\n    Returns: \n        purchaseOrder: The updated purchaseOrder object reflecting the new status.\n    \"\"\"\n    data = order.model_dump(exclude_unset=True, exclude_none=True) if order else self.model_dump(exclude_unset=True, exclude_none=True)\n    response = self._client._put(f\"/{self.endpoint}/{str(self.id)}\", json=data)\n    return purchaseOrder.from_json(response, self._client)\n</code></pre>"},{"location":"api/purchasing/#spyre.purchasing.create_sales_order_from_invoice","title":"<code>create_sales_order_from_invoice(invoice)</code>","text":"<p>Creates a Sales Order from an Invoice by copying relevant fields  and adjusting quantities and freight charges for order processing.</p> <p>Parameters:</p> Name Type Description Default <code>invoice</code> <code>Invoice</code> <p>The invoice object to convert.</p> required <p>Returns:</p> Name Type Description <code>SalesOrder</code> <code>SalesOrder</code> <p>A new Sales Order instance populated with data from the invoice, including negative freight and order quantities, and duplicated address and item records.</p> Notes <ul> <li>Freight amount is negated.</li> <li>Order and committed quantities are negated unless zero.</li> <li>Shipping carrier and tracking number fields are reset to None.</li> <li>Duplicate records are created for address, shipping address, and items    to avoid mutating the original invoice data.</li> </ul> Source code in <code>src/spyre/utils.py</code> <pre><code>def create_sales_order_from_invoice(invoice: Invoice) -&gt; SalesOrder:\n    \"\"\"\n    Creates a Sales Order from an Invoice by copying relevant fields \n    and adjusting quantities and freight charges for order processing.\n\n    Args:\n        invoice (Invoice): The invoice object to convert.\n\n    Returns:\n        SalesOrder: A new Sales Order instance populated with data from the invoice,\n            including negative freight and order quantities, and duplicated\n            address and item records.\n\n    Notes:\n        - Freight amount is negated.\n        - Order and committed quantities are negated unless zero.\n        - Shipping carrier and tracking number fields are reset to None.\n        - Duplicate records are created for address, shipping address, and items \n          to avoid mutating the original invoice data.\n    \"\"\"\n\n\n    return SalesOrder(\n        orderNo=invoice.orderNo,\n        division=invoice.division,\n        location=invoice.location,\n        profitCenter=invoice.profitCenter,\n        customer=deepcopy(invoice.customer),\n        currency=deepcopy(invoice.currency),\n        status=\"O\",\n        type=\"O\",\n        hold=False,\n        orderDate=invoice.orderDate,\n        address=create_duplicate_record(invoice.address, exclude_fields=[\"contacts.contact_type\"]),\n        shippingAddress=create_duplicate_record(invoice.shippingAddress),\n        customerPO=invoice.customerPO,\n        fob=invoice.fob,\n        incoterms=invoice.incoterms,\n        incotermsPlace=invoice.incotermsPlace,\n        referenceNo=None,\n        shippingCarrier=None,\n        shipDate=invoice.shipDate,\n        trackingNo=None,\n        termsCode=invoice.termsCode,\n        termsText=invoice.termsText,\n        freight=f\"-{invoice.freight}\",\n        subtotal=invoice.subtotal,\n        total=invoice.total,\n        items = [\n            create_duplicate_record(item).model_copy(update={\n                \"orderQty\": f\"-{item.orderQty}\" if item.orderQty != \"0\" else item.orderQty ,\n                \"committedQty\": f\"-{item.committedQty}\" if item.committedQty != \"0\" else item.committedQty\n            })\n            for item in invoice.items or []\n        ],\n        udf=deepcopy(invoice.udf),\n    )\n</code></pre>"},{"location":"api/sales/","title":"Sales","text":""},{"location":"api/sales/#spyre.sales.InvoiceClient","title":"<code>InvoiceClient</code>","text":"Source code in <code>src/spyre/sales.py</code> <pre><code>class InvoiceClient():\n\n    def __init__(self, client : SpireClient):\n        self.client = client\n        self.endpoint = \"sales/invoices\"\n\n    def get_invoice(self, id: int) -&gt; 'invoice':\n        \"\"\"\n        Retrieve a sales invoice by its ID.\n\n        Sends a GET request to the invoices endpoint to fetch the invoice data.\n\n        Args:\n            id (int): The ID of the invoice to retrieve.\n\n        Returns:\n            invoice: An invoice instance created from the response data.\n        \"\"\"\n        response = self.client._get(f\"/{self.endpoint}/{id}\")\n        return invoice.from_json(response, self.client)\n\n    def update_invoice(self, id: int, invoice : Invoice) -&gt; 'invoice':\n        \"\"\"\n        Update an existing invoice by ID.\n\n        Sends a PUT request with updated invoice data to the invoices endpoint.\n\n        Args:\n            id (int): The ID of the invoice to update.\n            invoice (Invoice): The Invoice model instance containing updated data.\n\n        Returns:\n            invoice: The updated invoice instance created from the response data.\n        \"\"\"\n        response = self.client._put(f\"/{self.endpoint}/{id}\", json=invoice.model_dump(exclude_none=True, exclude_unset=True))\n        return invoice.from_json(response, self.client)\n\n    def query_invoices(\n        self,\n        *,\n        query: Optional[str] = None,\n        sort: Optional[Dict[str, str]] = None,\n        filter: Optional[Dict[str, Any]] = None,\n        all: bool = False,\n        limit: int = 1000,\n        start: int = 0,\n        **extra_params\n    ) -&gt; List[\"salesOrder\"]:\n        \"\"\"\n        Query invoices with optional full-text search, filtering, multi-field sorting, and pagination.\n\n        Args:\n            query (str, optional): Full-text search string.\n            sort (dict, optional): Dictionary of sorting rules (e.g., {\"orderDate\": \"desc\", \"orderNo\": \"asc\"}).\n            filter (dict, optional): Dictionary of filters to apply (will be JSON-encoded and URL-safe).\n            all (bool, optional): If True, retrieves all pages of results.\n            limit (int, optional): Number of results per page (max 1000).\n            start (int, optional): Starting offset for pagination.\n            **extra_params (Any): Any additional parameters to include in the query.\n\n        Returns:\n            List[invoice]: List of wrapped invoice resources.\n        \"\"\"\n        return self.client._query(\n            endpoint=self.endpoint,\n            resource_cls=invoice,\n            query=query,\n            sort=sort,\n            filter=filter,\n            all=all,\n            limit=limit,\n            start=start,\n            **extra_params\n        )\n</code></pre>"},{"location":"api/sales/#spyre.sales.InvoiceClient.get_invoice","title":"<code>get_invoice(id)</code>","text":"<p>Retrieve a sales invoice by its ID.</p> <p>Sends a GET request to the invoices endpoint to fetch the invoice data.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the invoice to retrieve.</p> required <p>Returns:</p> Name Type Description <code>invoice</code> <code>invoice</code> <p>An invoice instance created from the response data.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def get_invoice(self, id: int) -&gt; 'invoice':\n    \"\"\"\n    Retrieve a sales invoice by its ID.\n\n    Sends a GET request to the invoices endpoint to fetch the invoice data.\n\n    Args:\n        id (int): The ID of the invoice to retrieve.\n\n    Returns:\n        invoice: An invoice instance created from the response data.\n    \"\"\"\n    response = self.client._get(f\"/{self.endpoint}/{id}\")\n    return invoice.from_json(response, self.client)\n</code></pre>"},{"location":"api/sales/#spyre.sales.InvoiceClient.query_invoices","title":"<code>query_invoices(*, query=None, sort=None, filter=None, all=False, limit=1000, start=0, **extra_params)</code>","text":"<p>Query invoices with optional full-text search, filtering, multi-field sorting, and pagination.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Full-text search string.</p> <code>None</code> <code>sort</code> <code>dict</code> <p>Dictionary of sorting rules (e.g., {\"orderDate\": \"desc\", \"orderNo\": \"asc\"}).</p> <code>None</code> <code>filter</code> <code>dict</code> <p>Dictionary of filters to apply (will be JSON-encoded and URL-safe).</p> <code>None</code> <code>all</code> <code>bool</code> <p>If True, retrieves all pages of results.</p> <code>False</code> <code>limit</code> <code>int</code> <p>Number of results per page (max 1000).</p> <code>1000</code> <code>start</code> <code>int</code> <p>Starting offset for pagination.</p> <code>0</code> <code>**extra_params</code> <code>Any</code> <p>Any additional parameters to include in the query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[salesOrder]</code> <p>List[invoice]: List of wrapped invoice resources.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def query_invoices(\n    self,\n    *,\n    query: Optional[str] = None,\n    sort: Optional[Dict[str, str]] = None,\n    filter: Optional[Dict[str, Any]] = None,\n    all: bool = False,\n    limit: int = 1000,\n    start: int = 0,\n    **extra_params\n) -&gt; List[\"salesOrder\"]:\n    \"\"\"\n    Query invoices with optional full-text search, filtering, multi-field sorting, and pagination.\n\n    Args:\n        query (str, optional): Full-text search string.\n        sort (dict, optional): Dictionary of sorting rules (e.g., {\"orderDate\": \"desc\", \"orderNo\": \"asc\"}).\n        filter (dict, optional): Dictionary of filters to apply (will be JSON-encoded and URL-safe).\n        all (bool, optional): If True, retrieves all pages of results.\n        limit (int, optional): Number of results per page (max 1000).\n        start (int, optional): Starting offset for pagination.\n        **extra_params (Any): Any additional parameters to include in the query.\n\n    Returns:\n        List[invoice]: List of wrapped invoice resources.\n    \"\"\"\n    return self.client._query(\n        endpoint=self.endpoint,\n        resource_cls=invoice,\n        query=query,\n        sort=sort,\n        filter=filter,\n        all=all,\n        limit=limit,\n        start=start,\n        **extra_params\n    )\n</code></pre>"},{"location":"api/sales/#spyre.sales.InvoiceClient.update_invoice","title":"<code>update_invoice(id, invoice)</code>","text":"<p>Update an existing invoice by ID.</p> <p>Sends a PUT request with updated invoice data to the invoices endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the invoice to update.</p> required <code>invoice</code> <code>Invoice</code> <p>The Invoice model instance containing updated data.</p> required <p>Returns:</p> Name Type Description <code>invoice</code> <code>invoice</code> <p>The updated invoice instance created from the response data.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def update_invoice(self, id: int, invoice : Invoice) -&gt; 'invoice':\n    \"\"\"\n    Update an existing invoice by ID.\n\n    Sends a PUT request with updated invoice data to the invoices endpoint.\n\n    Args:\n        id (int): The ID of the invoice to update.\n        invoice (Invoice): The Invoice model instance containing updated data.\n\n    Returns:\n        invoice: The updated invoice instance created from the response data.\n    \"\"\"\n    response = self.client._put(f\"/{self.endpoint}/{id}\", json=invoice.model_dump(exclude_none=True, exclude_unset=True))\n    return invoice.from_json(response, self.client)\n</code></pre>"},{"location":"api/sales/#spyre.sales.OrdersClient","title":"<code>OrdersClient</code>","text":"Source code in <code>src/spyre/sales.py</code> <pre><code>class OrdersClient():\n\n    def __init__(self, client: SpireClient):\n        self.client = client\n        self.endpoint = \"sales/orders\"\n\n    def get_sales_order(self, id: int = None, order_number: str = None) -&gt; \"salesOrder\":\n        \"\"\"\n        Retrieve a sales order by its ID or order number.\n\n        Args:\n            id (int, optional): The ID of the sales order to retrieve.\n            order_number (str, optional): The order number of the sales order to retrieve.\n\n        Returns:\n            salesOrder: A `salesOrder` wrapper instance containing the retrieved data.\n\n        Raises:\n            ValueError: If neither id nor order_number is provided, or if no matching order is found.\n        \"\"\"\n        if id is not None:\n            response = self.client._get(f\"/{self.endpoint}/{str(id)}\")\n            return salesOrder.from_json(response, self.client)\n        elif order_number is not None:\n            orders = self.query_sales_orders(query=order_number)\n            for order in orders:\n                if getattr(order, \"orderNo\", None) == order_number:\n                    return order\n            raise ValueError(f\"No order found for order number {order_number}\")\n        else:\n            raise ValueError(\"Either 'id' or 'order_number' must be provided.\")\n\n    def create_sales_order(self, sales_order : 'SalesOrder') -&gt; 'salesOrder':\n        \"\"\"\n        Create a new sales order.\n\n        Sends a POST request to the sales order endpoint .\n\n        Args:\n            sales_order (dict): A SalesOrder instance containing the sales order details.\n\n        Returns:\n            salesOrder: The created SalesOrder instance.\n\n        Raises:\n            CreateRequestError: If the creation fails or response is invalid.\n        \"\"\"\n\n        response =  self.client._post(f\"/{self.endpoint}\", json=sales_order.model_dump(exclude_unset=True, exclude_none=True))\n        if response.get('status_code') == 201:\n            location = response.get('headers').get('location')\n            parsed_url = urlparse(location)\n            path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n            id = path_segments[-1]\n            return self.get_sales_order(id)\n        else:\n            error_message = response.get('content')\n            raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n\n    def update_sales_order(self, id: int, sales_order : 'SalesOrder') -&gt; 'salesOrder':\n        \"\"\"\n        Update an existing sales order by ID.\n\n        Sends a PUT request to the sales order endpoint with the provided sales order data\n        to update the existing record. Returns a wrapped `salesOrder` object containing\n        the updated information.\n\n        Args:\n            id (int): The ID of the sales order to update.\n            sales_order (SaleOrder): A SalesOrder instance with the sales order details.\n\n        Returns:\n            salesOrder: An instance of the salesOrder wrapper class initialized with \n                        the updated data and client session.\n        \"\"\"\n        response = self.client._put(f\"/{self.endpoint}/{str(id)}\", json=sales_order.model_dump(exclude_none=True, exclude_unset=True))\n        return salesOrder.from_json(response, self.client)\n\n    def delete_sales_order(self, id: int) -&gt; bool:\n        \"\"\"\n        Delete a sales order by its ID.\n\n        Sends a DELETE request to the sales order endpoint to remove the specified\n        sales order from the system.\n\n        Args:\n            id (int): The ID of the sales order to delete.\n\n        Returns:\n            bool: True if the sales order was successfully deleted, False otherwise.\n        \"\"\"\n        return self.client._delete(f\"/{self.endpoint}/{str(id)}\")\n\n    def query_sales_orders(\n        self,\n        *,\n        query: Optional[str] = None,\n        sort: Optional[Dict[str, str]] = None,\n        filter: Optional[Dict[str, Any]] = None,\n        all: bool = False,\n        limit: int = 1000,\n        start: int = 0,\n        **extra_params\n    ) -&gt; List[\"salesOrder\"]:\n        \"\"\"\n        Query sales orders with optional full-text search, filtering, multi-field sorting, and pagination.\n\n        Args:\n            query (str, optional): Full-text search string.\n            sort (dict, optional): Dictionary of sorting rules (e.g., {\"orderDate\": \"desc\", \"orderNo\": \"asc\"}).\n            filter (dict, optional): Dictionary of filters to apply (will be JSON-encoded and URL-safe).\n            all (bool, optional): If True, retrieves all pages of results.\n            limit (int, optional): Number of results per page (max 1000).\n            start (int, optional): Starting offset for pagination.\n            **extra_params (Any): Any additional parameters to include in the query.\n\n        Returns:\n            List[salesOrder]: List of wrapped sales order resources.\n        \"\"\"\n        return self.client._query(\n            endpoint=self.endpoint,\n            resource_cls=salesOrder,\n            query=query,\n            sort=sort,\n            filter=filter,\n            all=all,\n            limit=limit,\n            start=start,\n            **extra_params\n        )\n\n    def create_sales_order_note(self, id: int , note_body : str, note_subject : str = \"Note\") -&gt; note:\n        \"\"\"\n        Create a new note on this sales order.\n\n        Args:\n            id (int): The id of the salesOrder to create a note on.\n            note_body (str): The body of the note. \n            note_subject (str): The subject of the note.\n        Returns:\n            note: The created note\n\n        Raises:\n            CreateRequestError: If the creation fails or response is invalid.\n        \"\"\"\n\n        note_model = Note(body=note_body, subject=note_subject)\n        response =  self.client._post(f\"/{self.endpoint}/{id}/notes/\", json=note_model.model_dump(exclude_unset=True, exclude_none=True))\n        if response.get('status_code') == 201:\n            location = response.get('headers').get('location')\n            parsed_url = urlparse(location)\n            path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n            id = path_segments[-1]\n            return CRMClient(client=self.client).get_note(id)\n        else:\n            error_message = response.get('content')\n            raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/sales/#spyre.sales.OrdersClient.create_sales_order","title":"<code>create_sales_order(sales_order)</code>","text":"<p>Create a new sales order.</p> <p>Sends a POST request to the sales order endpoint .</p> <p>Parameters:</p> Name Type Description Default <code>sales_order</code> <code>dict</code> <p>A SalesOrder instance containing the sales order details.</p> required <p>Returns:</p> Name Type Description <code>salesOrder</code> <code>salesOrder</code> <p>The created SalesOrder instance.</p> <p>Raises:</p> Type Description <code>CreateRequestError</code> <p>If the creation fails or response is invalid.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def create_sales_order(self, sales_order : 'SalesOrder') -&gt; 'salesOrder':\n    \"\"\"\n    Create a new sales order.\n\n    Sends a POST request to the sales order endpoint .\n\n    Args:\n        sales_order (dict): A SalesOrder instance containing the sales order details.\n\n    Returns:\n        salesOrder: The created SalesOrder instance.\n\n    Raises:\n        CreateRequestError: If the creation fails or response is invalid.\n    \"\"\"\n\n    response =  self.client._post(f\"/{self.endpoint}\", json=sales_order.model_dump(exclude_unset=True, exclude_none=True))\n    if response.get('status_code') == 201:\n        location = response.get('headers').get('location')\n        parsed_url = urlparse(location)\n        path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n        id = path_segments[-1]\n        return self.get_sales_order(id)\n    else:\n        error_message = response.get('content')\n        raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/sales/#spyre.sales.OrdersClient.create_sales_order_note","title":"<code>create_sales_order_note(id, note_body, note_subject='Note')</code>","text":"<p>Create a new note on this sales order.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The id of the salesOrder to create a note on.</p> required <code>note_body</code> <code>str</code> <p>The body of the note. </p> required <code>note_subject</code> <code>str</code> <p>The subject of the note.</p> <code>'Note'</code> <p>Returns:     note: The created note</p> <p>Raises:</p> Type Description <code>CreateRequestError</code> <p>If the creation fails or response is invalid.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def create_sales_order_note(self, id: int , note_body : str, note_subject : str = \"Note\") -&gt; note:\n    \"\"\"\n    Create a new note on this sales order.\n\n    Args:\n        id (int): The id of the salesOrder to create a note on.\n        note_body (str): The body of the note. \n        note_subject (str): The subject of the note.\n    Returns:\n        note: The created note\n\n    Raises:\n        CreateRequestError: If the creation fails or response is invalid.\n    \"\"\"\n\n    note_model = Note(body=note_body, subject=note_subject)\n    response =  self.client._post(f\"/{self.endpoint}/{id}/notes/\", json=note_model.model_dump(exclude_unset=True, exclude_none=True))\n    if response.get('status_code') == 201:\n        location = response.get('headers').get('location')\n        parsed_url = urlparse(location)\n        path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n        id = path_segments[-1]\n        return CRMClient(client=self.client).get_note(id)\n    else:\n        error_message = response.get('content')\n        raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/sales/#spyre.sales.OrdersClient.delete_sales_order","title":"<code>delete_sales_order(id)</code>","text":"<p>Delete a sales order by its ID.</p> <p>Sends a DELETE request to the sales order endpoint to remove the specified sales order from the system.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the sales order to delete.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the sales order was successfully deleted, False otherwise.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def delete_sales_order(self, id: int) -&gt; bool:\n    \"\"\"\n    Delete a sales order by its ID.\n\n    Sends a DELETE request to the sales order endpoint to remove the specified\n    sales order from the system.\n\n    Args:\n        id (int): The ID of the sales order to delete.\n\n    Returns:\n        bool: True if the sales order was successfully deleted, False otherwise.\n    \"\"\"\n    return self.client._delete(f\"/{self.endpoint}/{str(id)}\")\n</code></pre>"},{"location":"api/sales/#spyre.sales.OrdersClient.get_sales_order","title":"<code>get_sales_order(id=None, order_number=None)</code>","text":"<p>Retrieve a sales order by its ID or order number.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the sales order to retrieve.</p> <code>None</code> <code>order_number</code> <code>str</code> <p>The order number of the sales order to retrieve.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>salesOrder</code> <code>salesOrder</code> <p>A <code>salesOrder</code> wrapper instance containing the retrieved data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither id nor order_number is provided, or if no matching order is found.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def get_sales_order(self, id: int = None, order_number: str = None) -&gt; \"salesOrder\":\n    \"\"\"\n    Retrieve a sales order by its ID or order number.\n\n    Args:\n        id (int, optional): The ID of the sales order to retrieve.\n        order_number (str, optional): The order number of the sales order to retrieve.\n\n    Returns:\n        salesOrder: A `salesOrder` wrapper instance containing the retrieved data.\n\n    Raises:\n        ValueError: If neither id nor order_number is provided, or if no matching order is found.\n    \"\"\"\n    if id is not None:\n        response = self.client._get(f\"/{self.endpoint}/{str(id)}\")\n        return salesOrder.from_json(response, self.client)\n    elif order_number is not None:\n        orders = self.query_sales_orders(query=order_number)\n        for order in orders:\n            if getattr(order, \"orderNo\", None) == order_number:\n                return order\n        raise ValueError(f\"No order found for order number {order_number}\")\n    else:\n        raise ValueError(\"Either 'id' or 'order_number' must be provided.\")\n</code></pre>"},{"location":"api/sales/#spyre.sales.OrdersClient.query_sales_orders","title":"<code>query_sales_orders(*, query=None, sort=None, filter=None, all=False, limit=1000, start=0, **extra_params)</code>","text":"<p>Query sales orders with optional full-text search, filtering, multi-field sorting, and pagination.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Full-text search string.</p> <code>None</code> <code>sort</code> <code>dict</code> <p>Dictionary of sorting rules (e.g., {\"orderDate\": \"desc\", \"orderNo\": \"asc\"}).</p> <code>None</code> <code>filter</code> <code>dict</code> <p>Dictionary of filters to apply (will be JSON-encoded and URL-safe).</p> <code>None</code> <code>all</code> <code>bool</code> <p>If True, retrieves all pages of results.</p> <code>False</code> <code>limit</code> <code>int</code> <p>Number of results per page (max 1000).</p> <code>1000</code> <code>start</code> <code>int</code> <p>Starting offset for pagination.</p> <code>0</code> <code>**extra_params</code> <code>Any</code> <p>Any additional parameters to include in the query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[salesOrder]</code> <p>List[salesOrder]: List of wrapped sales order resources.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def query_sales_orders(\n    self,\n    *,\n    query: Optional[str] = None,\n    sort: Optional[Dict[str, str]] = None,\n    filter: Optional[Dict[str, Any]] = None,\n    all: bool = False,\n    limit: int = 1000,\n    start: int = 0,\n    **extra_params\n) -&gt; List[\"salesOrder\"]:\n    \"\"\"\n    Query sales orders with optional full-text search, filtering, multi-field sorting, and pagination.\n\n    Args:\n        query (str, optional): Full-text search string.\n        sort (dict, optional): Dictionary of sorting rules (e.g., {\"orderDate\": \"desc\", \"orderNo\": \"asc\"}).\n        filter (dict, optional): Dictionary of filters to apply (will be JSON-encoded and URL-safe).\n        all (bool, optional): If True, retrieves all pages of results.\n        limit (int, optional): Number of results per page (max 1000).\n        start (int, optional): Starting offset for pagination.\n        **extra_params (Any): Any additional parameters to include in the query.\n\n    Returns:\n        List[salesOrder]: List of wrapped sales order resources.\n    \"\"\"\n    return self.client._query(\n        endpoint=self.endpoint,\n        resource_cls=salesOrder,\n        query=query,\n        sort=sort,\n        filter=filter,\n        all=all,\n        limit=limit,\n        start=start,\n        **extra_params\n    )\n</code></pre>"},{"location":"api/sales/#spyre.sales.OrdersClient.update_sales_order","title":"<code>update_sales_order(id, sales_order)</code>","text":"<p>Update an existing sales order by ID.</p> <p>Sends a PUT request to the sales order endpoint with the provided sales order data to update the existing record. Returns a wrapped <code>salesOrder</code> object containing the updated information.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the sales order to update.</p> required <code>sales_order</code> <code>SaleOrder</code> <p>A SalesOrder instance with the sales order details.</p> required <p>Returns:</p> Name Type Description <code>salesOrder</code> <code>salesOrder</code> <p>An instance of the salesOrder wrapper class initialized with          the updated data and client session.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def update_sales_order(self, id: int, sales_order : 'SalesOrder') -&gt; 'salesOrder':\n    \"\"\"\n    Update an existing sales order by ID.\n\n    Sends a PUT request to the sales order endpoint with the provided sales order data\n    to update the existing record. Returns a wrapped `salesOrder` object containing\n    the updated information.\n\n    Args:\n        id (int): The ID of the sales order to update.\n        sales_order (SaleOrder): A SalesOrder instance with the sales order details.\n\n    Returns:\n        salesOrder: An instance of the salesOrder wrapper class initialized with \n                    the updated data and client session.\n    \"\"\"\n    response = self.client._put(f\"/{self.endpoint}/{str(id)}\", json=sales_order.model_dump(exclude_none=True, exclude_unset=True))\n    return salesOrder.from_json(response, self.client)\n</code></pre>"},{"location":"api/sales/#spyre.sales.invoice","title":"<code>invoice</code>","text":"<p>               Bases: <code>APIResource[Invoice]</code></p> Source code in <code>src/spyre/sales.py</code> <pre><code>class invoice(APIResource[Invoice]):\n    endpoint = \"sales/invoices/\"\n    Model = Invoice\n\n    def reverse(self) -&gt; salesOrder:\n        \"\"\"\n        Convert this invoice into a sales order.\n\n        This method uses the internal model of the invoice to create a new sales order\n        using the `create_sales_order_from_invoice` utility function. It then submits the\n        order through the OrdersClient.\n\n        Returns:\n            salesOrder: The created sales order instance returned by the API.\n        \"\"\"\n        order_converted = create_sales_order_from_invoice(self._model)\n        return OrdersClient(self._client).create_sales_order(order_converted)\n\n    def update(self , invoice_: \"Invoice\" = None) -&gt; 'invoice':\n        \"\"\"\n        Update this invoice.\n\n        Sends a PUT request with updated invoice data to the invoices endpoint.\n        If no order object is provided, updates the current instance on the server.\n\n        Args:\n            invoice_ (Invoice): The Invoice model instance containing updated data.\n\n        Returns:\n            invoice: The updated invoice instance created from the response data.\n        \"\"\"\n        data = invoice_.model_dump(exclude_unset=True, exclude_none=True) if invoice_ else self.model_dump(exclude_unset=True, exclude_none=True)\n        response = self._client._put(f\"/{self.endpoint}/{str(self.id)}\", json=data)\n        return invoice.from_json(response, self._client)   \n</code></pre>"},{"location":"api/sales/#spyre.sales.invoice.reverse","title":"<code>reverse()</code>","text":"<p>Convert this invoice into a sales order.</p> <p>This method uses the internal model of the invoice to create a new sales order using the <code>create_sales_order_from_invoice</code> utility function. It then submits the order through the OrdersClient.</p> <p>Returns:</p> Name Type Description <code>salesOrder</code> <code>salesOrder</code> <p>The created sales order instance returned by the API.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def reverse(self) -&gt; salesOrder:\n    \"\"\"\n    Convert this invoice into a sales order.\n\n    This method uses the internal model of the invoice to create a new sales order\n    using the `create_sales_order_from_invoice` utility function. It then submits the\n    order through the OrdersClient.\n\n    Returns:\n        salesOrder: The created sales order instance returned by the API.\n    \"\"\"\n    order_converted = create_sales_order_from_invoice(self._model)\n    return OrdersClient(self._client).create_sales_order(order_converted)\n</code></pre>"},{"location":"api/sales/#spyre.sales.invoice.update","title":"<code>update(invoice_=None)</code>","text":"<p>Update this invoice.</p> <p>Sends a PUT request with updated invoice data to the invoices endpoint. If no order object is provided, updates the current instance on the server.</p> <p>Parameters:</p> Name Type Description Default <code>invoice_</code> <code>Invoice</code> <p>The Invoice model instance containing updated data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>invoice</code> <code>invoice</code> <p>The updated invoice instance created from the response data.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def update(self , invoice_: \"Invoice\" = None) -&gt; 'invoice':\n    \"\"\"\n    Update this invoice.\n\n    Sends a PUT request with updated invoice data to the invoices endpoint.\n    If no order object is provided, updates the current instance on the server.\n\n    Args:\n        invoice_ (Invoice): The Invoice model instance containing updated data.\n\n    Returns:\n        invoice: The updated invoice instance created from the response data.\n    \"\"\"\n    data = invoice_.model_dump(exclude_unset=True, exclude_none=True) if invoice_ else self.model_dump(exclude_unset=True, exclude_none=True)\n    response = self._client._put(f\"/{self.endpoint}/{str(self.id)}\", json=data)\n    return invoice.from_json(response, self._client)   \n</code></pre>"},{"location":"api/sales/#spyre.sales.salesOrder","title":"<code>salesOrder</code>","text":"<p>               Bases: <code>APIResource[SalesOrder]</code></p> Source code in <code>src/spyre/sales.py</code> <pre><code>class salesOrder(APIResource[SalesOrder]):\n    endpoint = \"sales/orders/\"\n    Model = SalesOrder \n\n    def invoice(self) -&gt; \"invoice\":\n        \"\"\"\n        Invoice the current sales order.\n\n        Sends a POST request to create an invoice for this sales order.\n        Note that quotes (salesOrder with type \"Q\") cannot be invoiced.\n\n        Returns:\n            invoice (invoice): The created invoice object if successful.\n\n        Raises:\n            CreateRequestError: If invoice creation failed.\n\n        \"\"\"\n        response = self._client._post(f\"/{self.endpoint}/{str(self.id)}/invoice\")\n        if response.get('status_code') == 200:\n            data = response.get('content').get('invoice')\n            return salesOrder.from_json(json_data=data, client= self._client)\n        else:\n            error_message = response.get('content')\n            raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n\n    def process(self) -&gt; 'salesOrder':\n        \"\"\"\n        Set the status of the salesOrder to 'Processed' (status = 'P').\n\n        Sends a PUT request to update the status field of this Sales Oder.\n\n        Returns:\n            salesOrder: The updated salesOrder object reflecting the new status.\n        \"\"\"\n        response = self._client._put(\n            f\"/{self.endpoint}/{str(self.id)}\",\n            json={\"status\": \"P\"}    \n        )\n        return salesOrder.from_json(response, self._client)\n\n    def delete(self) -&gt; bool:\n        \"\"\"\n        Cancels or deletes the sales order.\n\n        Sends a DELETE request to the API to remove the sales order with the current ID.\n\n        Returns:\n            bool: True if the order was successfully deleted (HTTP 204 or 200), False otherwise.\n        \"\"\"\n\n        return self._client._delete(f\"/{self.endpoint}/{str(self.id)}\")\n\n    def update(self, order: \"salesOrder\" = None) -&gt; 'salesOrder':\n        \"\"\"\n        Update the sales order.\n\n        If no order object is provided, updates the current instance on the server.\n        If an order object is provided, updates the sales order using the given data.\n\n        Args:\n            order (salesOrder, optional): An optional salesOrder instance to use for the update.\n\n        Returns:\n            salesOrder: The updated salesOrder object reflecting the new status.\n        \"\"\"\n        data = order.model_dump(exclude_unset=True, exclude_none=True) if order else self.model_dump(exclude_unset=True, exclude_none=True)\n        response = self._client._put(f\"/{self.endpoint}/{str(self.id)}\", json=data)\n        return salesOrder.from_json(response, self._client)    \n\n    def add_note(self, note_body : \"str\" , note_subject : \"str\" = \"Note\") -&gt; note:\n        \"\"\"\n        Add a note to this sales order\n\n        Args:\n            note_body (str): the body of the note.\n            note_subject (str, \"Note\"): the subject of the note. the defualt value is just \"Note\"\n\n        Returns:\n            note: The note created.\n        \"\"\"\n\n        note_model = Note(body=note_body, subject=note_subject)\n        response =  self._client._post(f\"/{self.endpoint}/{str(self.id)}/notes/\", json=note_model.model_dump(exclude_unset=True, exclude_none=True))\n        if response.get('status_code') == 201:\n            location = response.get('headers').get('location')\n            parsed_url = urlparse(location)\n            path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n            id = path_segments[-1]\n            return CRMClient(client=self._client).get_note(id)\n        else:\n            error_message = response.get('content')\n            raise CreateRequestError(f\"/{self.endpoint}/{str(self.id)}/notes/\", status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/sales/#spyre.sales.salesOrder.add_note","title":"<code>add_note(note_body, note_subject='Note')</code>","text":"<p>Add a note to this sales order</p> <p>Parameters:</p> Name Type Description Default <code>note_body</code> <code>str</code> <p>the body of the note.</p> required <code>note_subject</code> <code>(str, Note)</code> <p>the subject of the note. the defualt value is just \"Note\"</p> <code>'Note'</code> <p>Returns:</p> Name Type Description <code>note</code> <code>note</code> <p>The note created.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def add_note(self, note_body : \"str\" , note_subject : \"str\" = \"Note\") -&gt; note:\n    \"\"\"\n    Add a note to this sales order\n\n    Args:\n        note_body (str): the body of the note.\n        note_subject (str, \"Note\"): the subject of the note. the defualt value is just \"Note\"\n\n    Returns:\n        note: The note created.\n    \"\"\"\n\n    note_model = Note(body=note_body, subject=note_subject)\n    response =  self._client._post(f\"/{self.endpoint}/{str(self.id)}/notes/\", json=note_model.model_dump(exclude_unset=True, exclude_none=True))\n    if response.get('status_code') == 201:\n        location = response.get('headers').get('location')\n        parsed_url = urlparse(location)\n        path_segments = parsed_url.path.rstrip(\"/\").split(\"/\")\n        id = path_segments[-1]\n        return CRMClient(client=self._client).get_note(id)\n    else:\n        error_message = response.get('content')\n        raise CreateRequestError(f\"/{self.endpoint}/{str(self.id)}/notes/\", status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/sales/#spyre.sales.salesOrder.delete","title":"<code>delete()</code>","text":"<p>Cancels or deletes the sales order.</p> <p>Sends a DELETE request to the API to remove the sales order with the current ID.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the order was successfully deleted (HTTP 204 or 200), False otherwise.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def delete(self) -&gt; bool:\n    \"\"\"\n    Cancels or deletes the sales order.\n\n    Sends a DELETE request to the API to remove the sales order with the current ID.\n\n    Returns:\n        bool: True if the order was successfully deleted (HTTP 204 or 200), False otherwise.\n    \"\"\"\n\n    return self._client._delete(f\"/{self.endpoint}/{str(self.id)}\")\n</code></pre>"},{"location":"api/sales/#spyre.sales.salesOrder.invoice","title":"<code>invoice()</code>","text":"<p>Invoice the current sales order.</p> <p>Sends a POST request to create an invoice for this sales order. Note that quotes (salesOrder with type \"Q\") cannot be invoiced.</p> <p>Returns:</p> Name Type Description <code>invoice</code> <code>invoice</code> <p>The created invoice object if successful.</p> <p>Raises:</p> Type Description <code>CreateRequestError</code> <p>If invoice creation failed.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def invoice(self) -&gt; \"invoice\":\n    \"\"\"\n    Invoice the current sales order.\n\n    Sends a POST request to create an invoice for this sales order.\n    Note that quotes (salesOrder with type \"Q\") cannot be invoiced.\n\n    Returns:\n        invoice (invoice): The created invoice object if successful.\n\n    Raises:\n        CreateRequestError: If invoice creation failed.\n\n    \"\"\"\n    response = self._client._post(f\"/{self.endpoint}/{str(self.id)}/invoice\")\n    if response.get('status_code') == 200:\n        data = response.get('content').get('invoice')\n        return salesOrder.from_json(json_data=data, client= self._client)\n    else:\n        error_message = response.get('content')\n        raise CreateRequestError(self.endpoint, status_code=response.get('status_code'), error_message=error_message)\n</code></pre>"},{"location":"api/sales/#spyre.sales.salesOrder.process","title":"<code>process()</code>","text":"<p>Set the status of the salesOrder to 'Processed' (status = 'P').</p> <p>Sends a PUT request to update the status field of this Sales Oder.</p> <p>Returns:</p> Name Type Description <code>salesOrder</code> <code>salesOrder</code> <p>The updated salesOrder object reflecting the new status.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def process(self) -&gt; 'salesOrder':\n    \"\"\"\n    Set the status of the salesOrder to 'Processed' (status = 'P').\n\n    Sends a PUT request to update the status field of this Sales Oder.\n\n    Returns:\n        salesOrder: The updated salesOrder object reflecting the new status.\n    \"\"\"\n    response = self._client._put(\n        f\"/{self.endpoint}/{str(self.id)}\",\n        json={\"status\": \"P\"}    \n    )\n    return salesOrder.from_json(response, self._client)\n</code></pre>"},{"location":"api/sales/#spyre.sales.salesOrder.update","title":"<code>update(order=None)</code>","text":"<p>Update the sales order.</p> <p>If no order object is provided, updates the current instance on the server. If an order object is provided, updates the sales order using the given data.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>salesOrder</code> <p>An optional salesOrder instance to use for the update.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>salesOrder</code> <code>salesOrder</code> <p>The updated salesOrder object reflecting the new status.</p> Source code in <code>src/spyre/sales.py</code> <pre><code>def update(self, order: \"salesOrder\" = None) -&gt; 'salesOrder':\n    \"\"\"\n    Update the sales order.\n\n    If no order object is provided, updates the current instance on the server.\n    If an order object is provided, updates the sales order using the given data.\n\n    Args:\n        order (salesOrder, optional): An optional salesOrder instance to use for the update.\n\n    Returns:\n        salesOrder: The updated salesOrder object reflecting the new status.\n    \"\"\"\n    data = order.model_dump(exclude_unset=True, exclude_none=True) if order else self.model_dump(exclude_unset=True, exclude_none=True)\n    response = self._client._put(f\"/{self.endpoint}/{str(self.id)}\", json=data)\n    return salesOrder.from_json(response, self._client)    \n</code></pre>"},{"location":"api/sales/#spyre.sales.create_sales_order_from_invoice","title":"<code>create_sales_order_from_invoice(invoice)</code>","text":"<p>Creates a Sales Order from an Invoice by copying relevant fields  and adjusting quantities and freight charges for order processing.</p> <p>Parameters:</p> Name Type Description Default <code>invoice</code> <code>Invoice</code> <p>The invoice object to convert.</p> required <p>Returns:</p> Name Type Description <code>SalesOrder</code> <code>SalesOrder</code> <p>A new Sales Order instance populated with data from the invoice, including negative freight and order quantities, and duplicated address and item records.</p> Notes <ul> <li>Freight amount is negated.</li> <li>Order and committed quantities are negated unless zero.</li> <li>Shipping carrier and tracking number fields are reset to None.</li> <li>Duplicate records are created for address, shipping address, and items    to avoid mutating the original invoice data.</li> </ul> Source code in <code>src/spyre/utils.py</code> <pre><code>def create_sales_order_from_invoice(invoice: Invoice) -&gt; SalesOrder:\n    \"\"\"\n    Creates a Sales Order from an Invoice by copying relevant fields \n    and adjusting quantities and freight charges for order processing.\n\n    Args:\n        invoice (Invoice): The invoice object to convert.\n\n    Returns:\n        SalesOrder: A new Sales Order instance populated with data from the invoice,\n            including negative freight and order quantities, and duplicated\n            address and item records.\n\n    Notes:\n        - Freight amount is negated.\n        - Order and committed quantities are negated unless zero.\n        - Shipping carrier and tracking number fields are reset to None.\n        - Duplicate records are created for address, shipping address, and items \n          to avoid mutating the original invoice data.\n    \"\"\"\n\n\n    return SalesOrder(\n        orderNo=invoice.orderNo,\n        division=invoice.division,\n        location=invoice.location,\n        profitCenter=invoice.profitCenter,\n        customer=deepcopy(invoice.customer),\n        currency=deepcopy(invoice.currency),\n        status=\"O\",\n        type=\"O\",\n        hold=False,\n        orderDate=invoice.orderDate,\n        address=create_duplicate_record(invoice.address, exclude_fields=[\"contacts.contact_type\"]),\n        shippingAddress=create_duplicate_record(invoice.shippingAddress),\n        customerPO=invoice.customerPO,\n        fob=invoice.fob,\n        incoterms=invoice.incoterms,\n        incotermsPlace=invoice.incotermsPlace,\n        referenceNo=None,\n        shippingCarrier=None,\n        shipDate=invoice.shipDate,\n        trackingNo=None,\n        termsCode=invoice.termsCode,\n        termsText=invoice.termsText,\n        freight=f\"-{invoice.freight}\",\n        subtotal=invoice.subtotal,\n        total=invoice.total,\n        items = [\n            create_duplicate_record(item).model_copy(update={\n                \"orderQty\": f\"-{item.orderQty}\" if item.orderQty != \"0\" else item.orderQty ,\n                \"committedQty\": f\"-{item.committedQty}\" if item.committedQty != \"0\" else item.committedQty\n            })\n            for item in invoice.items or []\n        ],\n        udf=deepcopy(invoice.udf),\n    )\n</code></pre>"},{"location":"api/spire/","title":"Spire","text":"<p>High-level interface to interact with the Spire API.</p> <p>This class wraps the lower-level API clients (Orders, Invoices, Customers, Inventory) into a unified interface, initializing them using shared authentication via <code>SpireClient</code>.</p> <p>Attributes:</p> Name Type Description <code>client</code> <code>SpireClient</code> <p>Authenticated Spire API client.</p> <code>orders</code> <code>OrdersClient</code> <p>Client for accessing sales orders.</p> <code>invoices</code> <code>InvoiceClient</code> <p>Client for accessing invoices.</p> <code>customers</code> <code>CustomerClient</code> <p>Client for accessing customer records.</p> <code>inventory</code> <code>InventoryClient</code> <p>Client for accessing inventory items.</p> <code>purchasing</code> <code>PurchasingClient</code> <p>Client for accessing purchasing records.</p> <code>purchasingHistory</code> <code>PurchasingHistoryClient</code> <p>Client for accessing purchasing history records.</p> Source code in <code>src/spyre/spire.py</code> <pre><code>class Spire:\n    \"\"\"\n    High-level interface to interact with the Spire API.\n\n    This class wraps the lower-level API clients (Orders, Invoices, Customers, Inventory) into a unified interface,\n    initializing them using shared authentication via `SpireClient`.\n\n    Attributes:\n        client (SpireClient): Authenticated Spire API client.\n        orders (OrdersClient): Client for accessing sales orders.\n        invoices (InvoiceClient): Client for accessing invoices.\n        customers (CustomerClient): Client for accessing customer records.\n        inventory (InventoryClient): Client for accessing inventory items.\n        purchasing (PurchasingClient): Client for accessing purchasing records.\n        purchasingHistory (PurchasingHistoryClient): Client for accessing purchasing history records.\n    \"\"\"\n    def __init__(self, host : str, company : str, username : str, password : str):\n        \"\"\"\n        Creates a Spire session.\n\n        Args:\n            host (str): Spire Server host (e.g., black-disk-5630.spirelan.com:10880).\n            company (str): Spire company.\n            username (str): Spire user username.\n            password (str): Spire user password.\n        \"\"\"\n        self.client = SpireClient(host, company, username, password)\n        self.orders = OrdersClient(self.client)\n        self.invoices = InvoiceClient(self.client)\n        self.customers = CustomerClient(self.client)\n        self.inventory = InventoryClient(self.client)\n        self.purchasing = PurchasingClient(self.client)\n        self.purchasingHistory = PurchasingHistoryClient(self.client)\n</code></pre>"},{"location":"api/spire/#spyre.Spire.__init__","title":"<code>__init__(host, company, username, password)</code>","text":"<p>Creates a Spire session.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Spire Server host (e.g., black-disk-5630.spirelan.com:10880).</p> required <code>company</code> <code>str</code> <p>Spire company.</p> required <code>username</code> <code>str</code> <p>Spire user username.</p> required <code>password</code> <code>str</code> <p>Spire user password.</p> required Source code in <code>src/spyre/spire.py</code> <pre><code>def __init__(self, host : str, company : str, username : str, password : str):\n    \"\"\"\n    Creates a Spire session.\n\n    Args:\n        host (str): Spire Server host (e.g., black-disk-5630.spirelan.com:10880).\n        company (str): Spire company.\n        username (str): Spire user username.\n        password (str): Spire user password.\n    \"\"\"\n    self.client = SpireClient(host, company, username, password)\n    self.orders = OrdersClient(self.client)\n    self.invoices = InvoiceClient(self.client)\n    self.customers = CustomerClient(self.client)\n    self.inventory = InventoryClient(self.client)\n    self.purchasing = PurchasingClient(self.client)\n    self.purchasingHistory = PurchasingHistoryClient(self.client)\n</code></pre>"}]}